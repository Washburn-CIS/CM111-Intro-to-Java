


<section xml:id="section.scope">
    <info>
        <title>Scope</title>
    </info>
    <p>
      When writing larger programs, you will find that some variable definitions will only work as you expect them to in some parts of the program. This is because variable definitions are bound to a <term>scope</term> within the program. </p>

    <p>
      In Java, variable scopes are limited to the code blocks they're defined in. The extent of a code block is everything in between the block's opening and closing curly braces. Once a variable is defined inside the scope of a code block, it can be referenced on any succeeding line, including those in nested code blocks (additional code blocks defined inside of the code block in question).
    </p>


    <example  xml:id="ex.basic-scope"
        >
        <title>Basic Scope Example</title>
        <p>Considering the following code:
<program language="java"><input>
{
  var x = 5;
  {
    var y = x + 5;
  }
  System.out.println(x);
  System.out.println(y);  // error, y is not defined in this scope
}
System.out.println(x);  // error, x is not defined in this scope
</input></program>

      Both of the commented-out print statements would be errors since the variables they reference are defined in a different scope. Note that the first print statement is valid because <c>x</c> is defined in the same scope as that statement.
        </p>
        <p>
          Another important thing to note is that the statement in the inner-most scope can legally access the variable x. If a block of code is opened inside another block of code, it will inherit all the variable definitions of its enclosing scope.
        </p>
    </example>


    <p>
      Blocks of code comprising the bodies of conditional statements, loops, and method definitions. Variables defined in the header of a for loop are constrained to the scope of the body of the for loop.
    </p>


    <example  xml:id="ex.for-loop-error"
        >
        <title>Common Scope Error with For Loops</title>
        <p>Considering the following code:
<program language="java"><input>
for(int x = 1; x &lt;= 10; x = x + 1);
    System.out.println(x);
</input></program>

      At first glance, it appears this code will print out the numbers <c>1</c> through <c>10</c>, however, there is a semi-colon at the end of the first line. When omitting curly braces, the body of a for loop will consist of a statement immediately following the loop header. Since a semicolon follows the loop header, it counts as the single statement, meaning the print statement on the second line is not part of the for loop's body. Thus, the reference to the variable <c>x</c> is not in the correct scope and will be caught as a syntax error.
        </p>
    </example>
</section>





























<section xml:id="section.for-loops">
    <info>
        <title>For Loops</title>
    </info>

<p>When writing loops, three components are very commonly included:
    <ul>
        <li>
            <p>Some local variable is declared and initialized, for instance a variable named <c>counter</c> could be initialized to <c>1</c>. </p>
        </li>
        <li>
            <p>That variable is tested as part of the while condition, for instance looping while <c>counter</c> is less than <c>10</c>.
            </p>
        </li>
        <li>
            <p>At the end of each iteration of the loop, the variable is altered in some way, for instance <c>counter</c> could be incremented at the end of each iteration of the loop. </p>
        </li>
    </ul>

Since nearly every while loop that we write contains these three components, and also because they play an important role in determining how the loop executes, Java provides a special syntax called a <c>for</c> loop that simply re-organizes these components to all reside at the front of the loop.
</p>

    <figure>
        <title>for-loop</title>
        <caption>Anatomy of a For Loop</caption>
        <image source="figures/for-loop.png"/>
    </figure>

<p><term>for loops</term> start with the <c>for</c> keyword and a pair of parentheses, just like a while loop, but inside the parentheses is first an expression (ending in a semicolon) that is executed before the loop starts, secondly a boolean expression (the same as the looping condition for the while loop), also ending in a semicolon, and finally a statement that is executed at the end of each loop (typically incrementing a variable). The last statement doesn't have a semicolon following it, but all three should be within the parentheses. The rest is identical to a while loop. </p>

<example><title>Totaling Numbers with a For Loop</title>
<p>Consider the following while loop which adds the numbers between 1 and 10:
</p>

<program language="java"><input>
int total = 0;
int count = 1;
while(count &lt;= 10) {
  total = total + count;
  count = count + 1;
}
</input></program>

    <p>Here is identical code written as a for loop:</p>

<program language="java"><input>
int total = 0;
for(int count = 1; count &lt;= 10; count = count + 1) {
  total = total + count;
}
</input></program></example>

    <p>Because code written with while loops and for loops perform the exact same task, we call for loops <term>syntactic sugar</term>, in that it is meant only to help with the look of your code, not the function of your code. Essentially, it is used to improve your coding style.</p>

<example><title>Iterate Through a String</title>
    <p>The following code will print each character of the string <c>message</c>, one character per line:
    </p>
<program language="java"><input>
String message = "hello";
for(int i=0; i &lt; message.length(); i = i + 1) {
  System.out.println(message.charAt(i));
}
</input></program>
</example>

</section>













<section xml:id="section.for-each">
    <info>
        <title>For-Each Loops</title>
    </info>

<p>While loops used to iterate over an array often looked very similar, so for loops were introduced as a more concise way to handle the task. <term>For-Each Loops</term> were introduced in Java 5 as an even more concise way to deal with these tasks, and are preferred whenever the programmer intends to iterate over each element of an array <em>sequentially</em> (that is, starting with the first, then the second, and so on until the last element).
</p>

    <p>
A for-each loop eliminates the index variable <c>i</c> entirely. Instead, the programmer must define a new variable that will hold a single element of the array through each iteration of the loop. The same keyword <c>for</c> is used. Following the definition of this new variable, the programmer must include a colon (<c>:</c>) and then an expression yielding the array to be iterated over (usually just a variable reference).
    </p>


<example>
    <p>Consider the following array of Strings:</p>

<program language="java"><input>
String[] names = new String[] { "Jane", "Billy", "Susie" };
</input></program>

<p>A for loop could be used to print each name out:</p>

<program language="java"><input>
for(int i=0; i &lt; names.length; i++) {
    System.out.println(names[i]);
}
</input></program>

<p>The following for-each loop will perform the exact same task with a little less code, and is a little easier to read and understand:
</p>

<program language="java"><input>
for(String name : names) {
    System.out.println(name);
}
</input></program>

<p>This makes it easier to use arbitrary expressions that yield arrays. For example, the following code snippet also does the same thing as the previous two, but doesn't require the initial variable definition:
</p>

<program language="java"><input>
for(String name : new String[] { "Jane", "Billy", "Susie" }) {
    System.out.println(name);
}
</input></program>
</example>
</section>










<section xml:id="section.continue-statements">
    <info>
        <title>Continue Statements</title>
    </info>

        <p>
          <term>continue statements</term> can be used within a loop when the remainder of the loop should not be executed, but the loop should not be terminated as it would be with a <c>break</c> statement. When a <c>continue</c> statement is executed, the enclosing loop will cease executing its current iteration and then resume execution with the next iteration of the loop. Note that, if a <c>continue</c> statement is encountered in a <c>for</c> loop, the update statement will still execute before the next iteration of the loop begins.
        </p>

        <p><c>continue</c> statements are very simple in their syntax. They consist of just a single keyword (<c>continue</c>) followed by a semicolon:
      </p>
      <program language="java"><input>
        continue;
      </input></program>
        <p>You will use <c>continue</c> statements within an <c>if</c> statement since you will only want to skip the remainder of an iteration of a loop because some other condition that arises. Perhaps the task of the current iteration of the loop is completed early or perhaps an error was encountered that should end the current iteration of the loop but not the entire task the loop is handling. </p>


      <example><title>Validating User Input</title>
        <p>
          Assume there is a method called <c>getUserResponse</c> that allows the user to enter in a numeric value. The following code will request a positive even integer from the user and validate the user's response. If the user provides such a value, it will be added to a running total of these numbers.
        </p>
        <program language="java"><input>
    int total = 0;
    while(true) {
      // get a number from the user
      System.out.print("provide a positive, even number: ");
      x = getUserResponse();

      if(x &lt;= 0) { // ensure user provided a positive number
        System.out.println("Error: enter a positive number.");
        continue;
      }

      if(x % 2 != 0) { // ensure user provided an even number
        System.out.println("Error: enter an even number.");
        continue;
      }

      // add the number to the total
      total = total + x;
      System.out.println("Total is currently " + total);
    }
        </input></program>
          <p>
            There are two <c>continue</c> statements used in this snippet of code. The first is used when it is detected that the user provided a number that is not positive. The <c>continue</c> statement forces the loop to restart and the user is once again prompted for a valid response. The second <c>continue</c> statement is executed if an odd number is provided by the user. In both cases, the statement that adds the number to the total is skipped if the user breaks either of the rules for proper input. Sample interaction with this snippet of code may look like the example below:
          </p>

<console>
provide a positive, even number: 4
Total is currently 4
provide a positive, even number: 93
Error: enter an even number.
provide a positive, even number: 8
Total is currently 12
provide a positive, even number: -2
Error: enter a positive number.
provide a positive, even number:
</console>
      </example>
</section>











<section xml:id="section.break-statements">
    <info>
        <title>Break Statements</title>
    </info>

    <p>Loops don't need to be terminated only when the loop condition becomes false. A loop can be terminated early by using a <term>break statement</term> inside of the loop. When a <c>break</c> statement is encountered, the enclosing loop will immediately terminate and execution will resume just after the closing brace of the
      loop.
    </p>

    <p><c>break</c> statements are very simple. They consist of just a single keyword (<c>break</c>) followed by a semicolon:
  </p>
  <program language="java"><input>
    break;
  </input></program>
    <p>You will use <c>break</c> statements within an <c>if</c> statement since you will only want to terminate the loop early because of some other condition that arises. You may want to use a break statement if an error occurs that must be processed. You can also intentionally begin an infinite loop (set the loop condition to <c>true</c>) and use break statements to end the loop. </p>


  <example><title>Searching for Values in an Array</title>
    <p>
      The following code will search through an array <c>arr</c> for the number <c>13</c>:
    </p>
    <program language="java"><input>
int i=0;
for(; i&lt; arr.length; i++) {
  if(arr[i] == 13) {
    break;
  }
}
    </input></program>
      <p>When this snippet of code completes executing, <c>i</c> will be the index for <c>arr</c> where the value <c>13</c> is located (or it will be <c>arr.length</c> if <c>13</c> doesn't appear in <c>arr</c>).
      </p>
  </example>

</section>














    
    
    
<section  xml:id="section.philosophy">
    <info>
        <title>Philosophy of this Book</title>
    </info>
    
    <subsection><title>Goals</title>
        <p>
            First and foremost, this book is intended to introduce students to programming and computer science. Beyond simply learning how to write programs in a particular programming language, this book is intended to assist in teaching students what programs are, what kind of problems can by solved by programs, how programs are used to solve problems, what the primary tools are for developing programs, and how students can progress in learning programming and computer science beyond the course in which they are using this book. For students who have had some experienceprogramming, perhaps in a self-taught environment, a course using this book should complement their experience by providing a solid background in programming fundamentals important to understanding more advanced concepts in computer science. To this end, this book doesn't avoid the technical terms and abstract concepts that a trade book may gloss over in an attempt to get students up and programming more quickly. 
        </p>
        <p>
            Secondly, this book is intended to introduce the Java programming language to someone new to programming. Prior programming experience is not assumed and the book is written for an audience that is programming for the first time. For this reason, this book is not intended to instill a mastery of Java and prioritizes instead the fundamental elements of programming that are applicable to students using any language, Java included, in the future. For students who want a more detailed explanation of a topic or wish to dive deeper in to the features of Java, references are made throughout the book to Oracle's official java language reference which is also freely available for use in a classroom setting: https://docs.oracle.com/javase/specs/jls/se10/html/index.html
        </p>
        <p>All that said, the material in this book could also be well suited to other purposes, such as a language-specific course on Java for students already past introductory computer science courses. In such cases, it is recommended that a customized version of the textbook be created (see the "Modular by Design" section below).</p>
    </subsection>
    
    <subsection><title>Why Java?</title>
        <p>Before heading any further, it's important to address a question you (the reader) have likely already answered, only because it bears some further consideration. The choice of language in CS1 is often not a choice for individual instructors. It might be dictated by department standards since future courses may use the same language. It might be partially dictated by the need for transfer students or students with AP credit to be able to move more quickly through a program. It might  even be partially dictated by the local industry that expect a certain set of proprietary skills in college graduates. Regardless of the reason you've chosen Java for your course, or in the case that you actually are currently openly considering adopting Java, I hope to convince you that it might be a better choice than you currently think, even if you already think it is a good one.</p>
        <p>Perhaps this section should be titled: "Why not Python?" Frankly, this is a good question. Before I get to Python, I should mention that my first programming language in academia was actually Scheme. Before I took H211 at Indiana University I had significant experience working with BASIC, C, and C++ -- none of which are languages I would ever teach to a beginner, in retrospect. I loved the way Scheme set all of the students on a level playing field, regardless of prior experience, but I loved even more how the simple syntax of Scheme allowed us to focus on fundamental programming concepts rather than the minutiae of a complex language like C++. Using the Scheme REPL also allowed me to learn quickly through ad-hoc experimentation in class. This took place in the 90's and it was still a more pedagogically effective approach for a CS1 course than anything I've seen since!</p>
        <p>Python has become a very popular CS1 language for many of the reasons Scheme remains the language of choice at IU. Python is also a natural scripting language, ships with a standard REPL, and through its syntax is more complex than Scheme, it's not as burdensome (some say "wordy") as Java has been known to be. It's also, like Scheme, a dynamically typed language. Not having to worry about assigning types to variables also makes it easier for programmers to get something up and running quickly in both Scheme and Python, which has obvious appeal to a CS1 instructor.</p>
        <p>Until recently, Java has had a very high barrier of entry for those developing simple programs. As a statically typed language, it was considered best suited to large, complex projects. Rather infamously, the most simple Java program you can write (hello world) is 5 lines long and contains enough programming concepts to span most of a CS1 course. Experimentation was difficult in Java because every change required recompilation, and a re-run through the program up until the point the change was made. </p>
        <p>Note that, in the previous paragraph, I was using past tense. Java SE 9 brought an official REPL to Java (jshell), which for me, changed everything. Other REPL's had been available before, none truly made Java a scripting language -- at best they were just a way to play with expressions. JShell is not only a robust REPL for experimenting with Java in a CS1 class, it's also a standard REPL, meaning that it can be taught in CS1 with the expectation that it will still be a useful proprietary skill for the students later in their career. Coupled with the increased use of type inference in Java SE 8 (lambdas) and Java SE 10 (local variables), Java is well suited to not only help students get their programs up and running quickly, but also benefit from static type checking, making it easier for them to both debug their programs and understand the importance of type systems in a modern programming language. </p>
    </subsection>
    
    <subsection><title>Experiential Learning</title>
        <p>As a colleague of mine likes to say, "Programming is not a spectator sport." As important as it is for a student to understand the difference between a conditional expression and a conditional statement, a student must also be able to understand programming in a more innate way and develop the faculties to solve programming problems involving all of these abstract concepts. Since this book assumes no prior experience programming, it is intended to be used in a highly active learning environment that involves programming experiences. For this reason, instructional sections are intentionally succinct and rely more on examples to help students understand the concepts being taught. It is also expected that instructors will take advantage of most or all exercises available through this book in a course utilizing it. This book is not intended to teach these concepts independent of a hands-on environment for instruction.</p>
        
        <p>The advent of JShell makes it much easier to employ a more experiential approach to teaching programming, but textbooks need to adapt. For many, the main concern is when to introduce object oriented concepts when teaching Java. Because of JShell, it is now possible to write Java programs without having to write a class definition, which allows us to focus immediately on more fundamental imperative programming concepts first such as expressions and statements. This book does not avoid the topic of objects as a data type entirely, but does delay teaching the <em>definition</em> of new object types to focus on the core concepts of algorithms and imperative programming.</p>
    
    </subsection>
    
    <subsection><title>Modular by Design</title>
        <p>This book is truly a free and open-source textbook in the sense that, not only is it free to use (according to the creative commons license available at the end of the book), but also instructors are free to download and modify the XML documents it was developed from (again, subject to the constraints of the creative commons license). Every institution has different needs and instructors may have a different perspective on a topic or example that they would like to inject. This is encouraged. This textbook can be entirely customized to an individual course all they way to the level of the exercises, which can be interspersed in-line throughout the custom textbook. </p>
        <p>Sections of this book are intentionally cohesive and minimally coupled (to borrow some programming terminology). Of course, some sections will depend on other sections (class definitions don't make much sense unless you've already seen method definitions), but these dependencies are listed in a remark in the source XML for each section. As long as a dependent section isn't listed before the section it depends on, there shouldn't be a problem for students using a modified version of this book. Examples also carry prerequisites that may extend beyond a chapter's prerequisites. Depending on the order the instructor uses, you may need to update or replace the examples used in some of the sections. </p>
        <p>Not all sections carry the same amount of content, and some instructors may wish to spend more or less time with some sections. Between 1-3 sections can be covered in a 50-minute class period. When ordering a custom version of this book, it's recommended that you not include every section on, for instance, expressions, all in a row, but rather spread them out and cover them when they are most relevant to other material or projects you're using in the course. The standard version of the book does not group all related concepts in to single chapters for this purpose. Instead, each chapter is intended to cover approximately a weeks' worth of material in the order it is expected to be presented in class. </p>
    </subsection>
</subsection>










<section xml:id="section.scripts">
    <info>
        <title>Scripts</title>
    </info>

    <p>
    	Together, a collection of statements comprises an imperative computer <term>program</term>. Even one statement by itself can be a program (such as the hello world example). However, typing each of these statements in to the REPL is tedious. Any useful programming language has a means to easily store and run programs.
    </p>

    <subsection>
    	<title>JShell Scripts</title>
    	<p>JShell also introduces a facility for this purpose that wasn't previously available to Java programmers. All of the statements you type in to a JShell session can be saved to a file by typing the following command in to JShell:
<program language="java"><input>
/save myscript.jsh
</input></program>
    	where <filename>myscript.jsh</filename> can be any file name of your choosing. A series of statements saved to a file in any programming language referred to as a <term>script</term>. The <filename>.jsh</filename> extension distinguishes in the filename distinguishes this file as a JShell script that can be loaded and executed. In fact, you can load and execute a script you've previously saved in JShell by typing in the following command:
<program language="java"><input>
/open myscript.jsh
</input></program>
    	</p>

        <xi:include href="../../examples/average-script.xml" parse="xml"/>

        <p>You may need to download a text editor if you wish to edit these scripts that you create. You can also use a text editor to create a new script from scratch. Some text editors have nice features for programmers like syntax highlighting. If you're using Windows, my favorite editor is Notepad++: <uri>https://notepad-plus-plus.org/</uri>. For any system, jedit (which was developed in Java) is also a good option: <uri>http://www.jedit.org/</uri>.
        </p>

        <p>
          Note that JShell was not officially meant to make Java in to a scripting language, and as such it has some frustrating limitations for this purpose. In particular, reading input from the user may not work as expected when running JShell instructions as a script. There are some workarounds available for this shortcoming, however.
        </p>
    </subsection>


    <subsection>
    <title>Inline Comments</title>
    	<p>
    		Programs that you write will quickly become so complex that it may not be easy to look at your code and understand what it will do (or what it is intended to do). Programmers deal with this problem with a liberal use of comments -- portions of source code that are intended to be read by other programmers and not interpreted as an instruction in the program.
    	</p>
    	<p>
    		The most common type of comments you'll find in any programming language are called inline comments (also called end-of-line comments, since they appear at the end of lines). In Java, at any point in a line of code, you can type two slashes. Everything following those slashes is ignored. Thus, its only purpose is to be read by you or other programmers to help understand your program.
    	</p>
    	<p>
    		Inline comments can also be used as placeholders for future instructions while you're writing a program. In this way, they can be seen as a go-between when converting the steps of an algorithm in to an actual computer program.
    	</p>

    	<p>
    		More often inline comments are used to explain what a significant or particularly complex snippet of code is intended to do (in plain English). It is often helpful to write these comments <em>first</em> and then write the code the comments are describing, but they can also be added to code later after a programmer realizes their code might not be so easy to follow.
    	</p>
    	<p>
    		There is a bit of an art to writing comments well, just as there is an art to writing programs well. Too few comments and it may not be clear what a program is doing. This can also make errors in the program harder to detect. Too many comments can make a program laborious to read and also wastes the programmer's time since writing comments takes careful thought. There are many rules of thumb, but some important ones are:
    	    <ul>
    	        <li>
    	            <p>Use descriptive variable names that do a lot of the job a comment might be intended for. If the variable's role is very simple, you may not need a comment describing its purpose. </p>
    	        </li>
    	        <li>
    	            <p>Do not use comments that merely repeat what a statement is doing, but rather explain the purpose behind one or more statements if that purpose is not immediately obvious. </p>
    	        </li>
    	        <li>
    	            <p>Otherwise, if it's not immediately clear what a statement is doing, it may deserve a comment, but put some thought in to whether your comment should cover just that one line of code, or perhaps several that are working closely together.</p>
    	        </li>
    	    </ul>
    	</p>

        <xi:include href="../../examples/commenting-averaging.xml" parse="xml"/>
    </subsection>
</section>






<section xml:id="section.command-line-arguments">
    <info>
        <title>Command-Line Arguments</title>
    </info>
    <p>
Though you should understand what the type <c>String[]</c> means at this point (an array of string values), it may not be clear why a parameter with this type must be provided to the main method. The purpose of this parameter is to hold any <term>command-line arguments</term> that may be provided to your application when it is started at the command prompt. This would allow you to write an application similar to <em>javac</em> itself!
    </p>
    <p>
Consider the following example program:
    </p>
<program language="java"><input>
<xi:include href="../../examples/code/CommandLineDemo.java" parse="text"/>
</input></program>

    <p>
    This application prints out each of the command line arguments given to it when it is executed. These arguments are specified at the end of the <em>java</em> command that starts the JRE.
    </p>

    <p>
    For example, if you were to compile and run this program with the following command:
    </p>
<console>
    <input>
    java CommandLineDemo here are some arguments
  </input>
</console>
    <p>
    ...the following would be printed to the screen:
    </p>

<console>
<output>
here
are
some
arguments
</output><!-- TODO: check to see if this renders correctly /-->
</console>
</section>


<section xml:id="section.applications">
    <info>
        <title>Java Applications</title>
    </info>

    <p>
        Previous sections explained how Java classes can be used to hold collections of static methods. They are also used as the entry points in to stand-alone Java applications.
    </p>
    <subsection>
        <title>Main Methods</title>
        <p>
        To run a java application, you must provide the Java runtime environment (JRE) with the name of a class representing a Java application. The JRE will then search for one particular static method called <c>main</c> and execute it. This is called the <term>entry point</term> to the application.
      </p>
      <p>
        The JRE is very picky about how <c>main</c> should be defined. Firstly, the name must be exact -- <c>main</c> must not be capitalized or otherwise misspelled. Next, the method (like the class definition) must be declared to be public. It also must be a static method, so both of these keywords need to preceed the rest of the method definition (typically public comes first, but the order is more of a style issue). Next, the return type of the method must be void. Finally, the method must have one parameter. The parameter can be named anything you want, though by convention it is given the name <c>args</c>. What is important is that the type of this parameter is an array of strings:  <c>String[]</c>.

        Putting this all together, the following serves as an example of a complete Java application:
        </p>
        <program language="java"><input>
<xi:include href="../../examples/code/Hello.java" parse="text"/>
            </input></program>
        <p>
        This is the classic <em>hello world</em> program that is often given on the first day of a programming class. In many languages, <em>Hello World</em> is simply a one-line program, making this a convienent place to start in an introductory programming class. However, Java was designed with more complex software development in mind, and a more complex <em>Hello World</em> example is one of the unintended side effects of that choice. By starting with a tool like JShell, you were able to learn each of the concepts present in this code before using them in an application (with the exception of the <c>public</c> keyword, to some extent).

        Note that this program would have to be defined in a file called <c>Hello.java</c>.
        </p>
    </subsection>
    <subsection>
        <title>Compiling and Running Java Programs</title>

        <p>
          If you develop a java file such as <c>Hello.java</c>, you must first compile it before you run it. Recall that typing <em>jshell</em> at the command prompt started up the jshell REPL. Similarly, you can compile this Java program at the command prompt by typing:
       </p>
       <console><input>javac Hello.java</input></console>
       <p>
          If the command was successful, you should see a file in your directory called <c>Hello.class</c>. If it was unsuccessful, you will recieve an error message. Generally, you can compile any other Java file by including its file name in the place of <c>Hello.java</c>.
        </p>
        <p>
          Once your program is compiled successfully, you can run it by typing the command:
        </p>
        <console><input>java Hello</input></console>
        <p>
          This starts up the JRE and tells it to look for a main method in the class <c>Hello</c>. If you did not properly define your main method, you may receive an error message at this point. Otherwise, you will see the welcome message printed in the console.
        </p>

    </subsection>
</section>






<section xml:id="void-methods">
    <info>
        <title>Methods with No Return Type</title>
    </info>
    
    <p>
Not every method will need to return a value. This section will look at at one possible rationale for writing such a method.
    </p>
    <subsection>
        <title>The void Keyword</title>
        <p>
            Though not every method has a return value, method definitions require \textit{something} in the place of the return type in the method definition header. If no value is returned by the method, the \textbf{void} keyword is used to indicate such. If you use the void keyword in your method definition, you are not required to have a return statement in your method definition. Thus, the following is legal:
        </p>
        
<program language="java"><input>
void methodWithNoReturnStatement() {
// this method literally does nothing
}
</input></program>

    </subsection>
    <subsection>
        <title>Printing to Standard Output</title>
        <p>We've received messages back from the REPL each time we evaluate an expression, but perhaps we would like a message to be delivered somewhere during the execution of our program. Many ``text-based'' applications interact with their users solely through messages printed to a console (such as the REPL itself). Java has a special function for printing such messages to what is called \textit{standard output} or \textit{the console}. In the case of jshell, standard output is simply the jshell screen, so any messages you print while using jshell will show up there.
        </p>
        
        <p>The method we will use to print to standard output is unfortunately (and infamously) somewhat complicated looking. Technically, it is an instance method that we call from a PrintWriter object. The PrintWriter object in question is a static variable in the \textbf{System} class called \textbf{out}, and the instance method we'll call from this object is called textbf{println}. So all together, we'll be calling this method by calling \textbf{System.out.println}. If the last sentence is all you remember from this paragraph, that's all you'll need for the rest of the semester. 
            
        </p>
        
        <p>This method will take one argument -- whatever we want printed to standard output. So, if we want to print the number 5 to our jshell screen, we can use the following method call:
        </p>
        
        <program language="java"><input>
System.out.println(5);
        </input></program>
        
        <p>Note that this method doesn't return anything. It will take any type of expression we give it, however. So the following code:
        </p>
        
        <program language="java"><input>
System.out.println("Joseph Kendall-Morwick");            
        </input></program>
        
        <p>prints my name to standard output, and the following code:</p>
        
        <program language="java"><input>System.out.println(1 + 1 == 2);</input></program>
        
        <p>
            prints the value \textit{true} to standard output.  Note that if you don't want a newline printed, you can use System.out.print instead. This allows you to make multiple calls without continuing to the next line. For instance:
        </p>
        
        
<program language="java"><input>
System.out.print("hi");
System.out.print(" ");
System.out.print("there");
</input></program>
        <p>would print:</p>
        
<console><output>hi there</output></console>
    </subsection>
</section>



<section xml:id="section.varargs">
    <info>
        <title>Variable Number of Arguments</title>
    </info>

<p>All the method definitions we've examined thus far have required the programmer to be explicit about the number of parameters for the method and their types. Thus the programmer can't define a method that could take either 1, 2, or 3 arguments -- the number of arguments would always need to be the same.
</p>


    <p>
There is a way around this limitation. We could define a method that has an array-type parameter. The array argument we pass in to this method could be of any length, so we could package our arguments inside of it.
</p>

<example>
    <title>Sum an Array of Integers</title>
<p>If we wanted to write a method that would add several numbers together, we could package all those numbers in an array before we pass them to the method:
</p>
<program language="java"><input>
  int sum(int[] numbers) {
    int total = 0;
    for(int number : numbers) {
      total += number;
    }
    return total;
  }
</input></program>

<p>If we had three integer variables we wanted to add together, we could then pass them in within a literal array:
</p>

<program language="java"><input>
  sum(new int[] {a, b, c})
</input></program>

</example>
<p>
Since Java 5, variable number of arguments has been supported in Java, allowing us to perform the same task as the method above, but with a cleaner looking syntax. Using the varargs syntax, we'll declare that our method accepts an integer instead of an array. The difference will be that we'll include an ellipsis in between the type (<c>int</c>) and the variable name. The variable will still hold an array of integers in this case, not a single integer. This syntax can be used for any type (not just integers). You could write a varargs method that takes an arbitrary number of <c>String</c> parameters, for example. 
</p>

<example>
    <title>Sum a Variable Number of Integer Arguments</title>
<p>We could rewrite the example above using variable arguments as follows:
</p>
<program language="java"><input>
  int sum(int ... numbers) {
    int total = 0;
    for(int number : numbers) {
      total += number;
    }
    return total;
  }
</input></program>

<p>There is very little difference in the method definition, but now we don't need to create a literal array when we pass in a variable number of arguments. This version of sum can be called as follows:
</p>

<program language="java"><input>
  sum(a, b, c)
</input></program>
</example>
</section>



<section xml:id="section.overloading">
    <info>
        <title>Overloading Method Parameters</title>
    </info>

<p>What if the programmer wanted to develop a method that could take more than one type of argument? You may have noticed in the past that the <c>abs</c> method in the <c>Math</c> class works with either <c>int</c> values or <c>double</c> values. That is because there are two different implementations of this method, one for each of these parameter data types. This is called <term>overloading</term>.
</p>
    <p>
Methods in Java are not identified by their name alone. If you were to call <c>Math.abs(5)</c>, the Java compiler will search for a method named <c>abs</c> that has exactly one parameter of type <c>int</c> to bind this call to. There may be another method named <c>abs</c> that has a parameter of type <c>double</c>, or more than one parameter, or no parameters, etc..
    </p>

    <example>

        <p>Consider the following method definitions:</p>

<program language="java"><input>
int abs(int a) {
  System.out.println("abs was called with an int");
  return a > 0 ? a : -a;
}

double abs(double a) {
  System.out.println("abs was called with an double");
  return a > 0 ? a : -a;
}
</input></program>

<p>The implementations of these methods look nearly identical, but if you enter them in to jshell and then evaluate the following statements:
</p>
<program language="java"><input>
abs(-5);
abs(-5.0);
</input></program>

<p>You will see that one returns an integer value and the other returns a double value, as well as each printing out a different message.
</p>
    </example>
</section>


<section xml:id="section.method-definitions">
    <info>
        <title>Method Definitions</title>
    </info>
    
    <p>In prior sections we used method calls to do some of the computing for us. For example, a call to the <c>max</c> method in the <c>Math</c> class was a simple way to achieve what would have otherwise required more detailed code. In this section you will learn how to define your own custom methods. 
    </p>
    
    <p>
        Method definitions are a bit more involved than our previous topics. Methods take data (arguments) as input (through <term>parameters</term>) and return data as output (called the <term>return value</term>). The data types for both a method's input and output must be specified (similar to how you could specify the data type when you create a variable, though in this case it's required). Below is a diagram of the syntax of a method definition.
    </p>
  
    <figure>
        <title>method-definition</title>
        <caption>Anatomy of a Method Definition</caption>
        <image source="figures/method-definition.png"/>
    </figure>
  
        <p>
            A method definition consists of a header (or signature) defining the input and output data types, and a method body. Let's first take a look at the contents of the signature. First is a data type for the data returned by the method. For instance, the <c>abs</c> method in the <c>Math</c> class returns a double, so it's return type would be <c>double</c>. Next is the name of the method. 
        </p><p>
    So far, the definition looks a lot like a variable definition, but we're not quite finished. We also need to define parameters for the method. Parameters are variables that will hold the input values for the method (the input values are what we referred to as arguments in prior sections). Following the name of the method is a pair of parentheses with definitions of the parameters in between the parentheses. Each parameter definition consists of a data type followed by the name of the parameter (just like the variable definitions we saw previously but without the semicolon at the end). There may be zero or more parameter definitions, separated by commas. 
        </p><p>
    The method body consists of an open curly brace, 0 or more statements, and a closing curly brace. Unlike if statements, the method body must be contained within two curly braces (there is not option for a single-statement body with no curly braces). These statements can do anything you want with the restriction that your method must reach a special kind of statement called return statement when it is finished (with some exceptions -- but for now assume this is always true). The return statement must be the last statement executed in the method and it returns the value that a call to the method would evaluate to. 
    </p>
        
        <example><title>Square a Number</title>
        <p>Below is the definition of a method that will simply square the number passed in to it.</p>
<program language="java"><input>
int square(int x) {
  return x * x;
}
</input></program>
            <p>Note that it has only one parameter, <c>x</c>, and one statement in the method body, the return statement. Defining and then calling this method in jshell will look like this:</p>
            
<console>
<prompt>jshell> </prompt><input>int square(int x) {
   ...>   return x * x;
   ...> }</input>
|  created method square(int)

<prompt>jshell> </prompt><input>square(4)</input>
$2 ==> 16

<prompt>jshell> </prompt><input>square(10)</input>
$3 ==> 100

</console>
            
            <p>Notice that jshell doesn't include the name of the parameter <c>x</c>
            in the message reporting that you successfully defined the method. That's because the
            name of the parameter is ultimately not important. The parameter's name is meant to help
            make the code defining your method easier to read and understand, and also to describe
            the purpose of the parameter to the programmer writing code that calls it. What's most
            important from a functional perspective is that you've defined a method that can take an
                <c>int</c> type argument and that it will return another <c>int</c> type
            value to you. </p>
        </example>
        <example><title>Add Two Numbers</title>
            <p>Below is an example of a method definition with more than one parameter. It might not be particularly useful, but it demonstrates how to work with more than one argument in your methods:</p>
<program language="java"><input>
int add(int x, int y) {
  return x + y;
}
</input></program>     
            <p>Calling this method in jshell would look like this:</p>
<console>
<prompt>jshell> </prompt><input>add(4, 5)</input>
$2 ==> 9

<prompt>jshell> </prompt><input>add (10, -2)</input>
$3 ==> 8
</console>
        </example>
        
        <example><title>Ultimate Answer</title>
        <p>Some methods don't have any parameters at all. For example, below is the definition of a method that simply returns the value <c>42</c>:</p>
<program language="java"><input>
int ultimateAnswer() { 
  return 42;
}
</input></program>  
            <p>Calling this method in jshell would look like this:</p>
            
<console>
<prompt>jshell> </prompt><input>ultimateAnswer()</input>
$2 ==> 42    
</console>   
            <p>This method clearly doesn't do much and there are better alternatives to storing a single value, but there will be many opportunities for writing a meaningful method with no parameters as long as it performs some useful side effect, like printing to the screen.</p>
        </example>
    
</section>



<section xml:id="section.strings">
    <info>
        <title>Strings</title>
    </info>
    <p>A single character by itself doesn't convey much. The kind of data we more often want to
        work with is a sequence of multiple characters, like a name or address field, or even
        something longer and more complex like a news article or a computer program. Java has a
        data type that fits this role: the <c>String</c>. While a character literal only holds
        a single value, such as <c>'h'</c>, a string can hold 0 or more character
        values. Thus, strings can represent more complex data like names, sentences, or even this
        entire book! You can create a variable of type <c>String</c> as follows: </p>
    <program language="java"><input>String name;</input></program>
<p>
    Note that the type in that variable declaration is capitalized. That's because, unlike <c>char</c>'s and <c>int</c>'s, the string type is an object type (not a primitive type). Thus, when we use the string type in Java code (such as the example above), it must be capitalized. However, unlike <c>Point</c>s and other objects we've played with, strings are a special object type in Java in that they see very heavy usage and also have some special syntax associated with them (described in the following sections).
</p>
<section>
    <title>String Literals</title>

    <p>String literals have a special syntax somewhat similar to character literals. Character literals are a single character surrounded by single quotes, such <c>'a'</c>. String literals are similar, but as noted, there may be more than one character in the string, and we use double quotes to surround them. For example, the following code initializes the name variable from the previous example with my name as a value: </p>
    <program language="java"><input>name = "Joesph Kendall-Morwick";</input></program>

    <p>Note that string literals can contain all sorts of characters, including spaces and dashes. Strings also distinguish between upper and lower case characters. Character literals work just the same way, but character literals hold exactly one character.
    </p>

    <p>String literals may also hold zero characters. For instance:</p>

    <program language="java"><input>name = "";</input></program>

    <p>is also legal. Note that the empty string (above) is still a string value! It doesn't mean there isn't a string held by the variable <c>name</c>. If <c>name</c> held no value, we would say it holds the <c>null</c> value, just as any other object-type variable that doesn't hold a value. Recall that <c>null</c> is a keyword representing this value:
    </p>

    <program language="java"><input>name = null;</input></program>

    <p>Note that there are no quotes around <c>null</c>, since it is a keyword. </p>

</section>


    <subsection>
        <title>String Concatenation</title>

        <p>Two string values may be joined together with the concatenation operator.
            Unfortunately, you've technically already seen the concatenation operator because it
            uses the same symbol as the addition operator (+). However, they are considered distinct
            operators since they take distinct actions on their operands. You will end up with
            addition or concatenation depending on the data types of the operands. Allowing an
            operator to take on multiple meanings depending on the types of the operands is more
            generally referred to as <term>operator overloading</term>. </p>

<example><title>Basic Concatenation</title>
    <p>The following code:</p>
<program language="java"><input>
String fullName = "Joseph" + " " + "Kendall-Morwick";
</input></program>
    <p>
        will store a single string value representing my full name in the variable <c>fullName</c>.</p>
</example>

<p>In fact, concatenation is performed when even just one of the operands is a string value. The other value will be coerced (transformed) in to a string value.
</p>


<example><title>Concatenating non-Strings</title>
    <p>The following code:</p>
<program language="java"><input>
String message = "my favorite number is " + 5;
</input></program>
    <p>will store a single string value holding the message "my favorite number is 5" in the variable <c>message</c>.</p>
</example>
    </subsection>
<subsection>
    <title>String Instance Methods</title>

    <p>The string class has many useful instance methods. We'll take a look at five of the most important ones.
    </p>

    <subsubsection><title>length</title>
        <p>The <c>length</c> instance method has no parameters but returns the length of the string (as an integer).
        </p>

    <example>
        <title>Finding the Length of a String</title>

        <program language="java"><input>"hello".length() </input></program>

        <p>evaluates to the value 5 whereas</p>

        <program language="java"><input>"".length()</input></program>

        <p>evaluates to the value 0</p>
    </example>
    </subsubsection>

    <subsubsection><title>equals</title>

        <p>The <c>equals</c> instance method takes another String as input and returns a boolean value (<c>true</c> or <c>false</c>) indicating whether the two strings (the argument and the string from which the method is being called) have the exact same contents or not. Boolean values are described in more detail in another section. </p>
        <example>
            <title>Comparing two Strings</title>
            <program language="java"><input>"hello".equals("hello") </input></program>
            <p>evaluates to the value <c>true</c> whereas</p>
            <program language="java"><input>"hello".charAt("Hello") </input></program>
            <p>evaluates to the value <c>false</c></p>
        </example>
    </subsubsection>

    <subsubsection><title>charAt</title>

        <p>The <c>charAt</c> instance method takes the location (called the index or offset) of a character in the string and returns just that character (as a character-type value). The tricky part of working with string indexes is that the first index is zero (not one). </p>
        <example>
            <title>Pulling a character out of a String</title>
            <program language="java"><input>"hello".charAt(0) </input></program>
            <p>evaluates to the value <c>'h'</c> whereas</p>
            <program language="java"><input>"hello".charAt(4) </input></program>
            <p>evaluates to the value <c>'o'</c></p>
        </example>
    </subsubsection>

    <subsubsection><title>char</title>

        <p>The <c>indexOf</c> instance method takes a character you're searching for as input and returns the first index of where it's found in the string. If the character is not present in the string, <c>-1</c> is returned instead. </p>

    </subsubsection>

    <subsubsection><title>substring</title>

        <p>        The <c>substring</c> instance method takes two integer values (indexes) as input and returns a substring of the original string starting at the first index and ending just before the last index. Be mindful of the fact that the first index given indicates where the substring starts (and the character at this index is included in the resulting substring), but the second index is expected to be one greater than the index of the last character included (so the character at the second index is not included). The second index is also optional -- if it is omitted, all characters following the first index are included in the resulting substring. This can be a little confusing, so make sure that the examples below make sense and try some others out in JShell.
  </p>
        <example>
            <title>Pulling a substring out of a String</title>
            <program language="java"><input>"hello".substring(1, 3) </input></program>
            <p>evaluates to the value <c>"el"</c></p>
        </example>
        <example>
            <title>Pulling a prefix out of a String</title>
            <program language="java"><input>"hello".substring(1) </input></program>
            <p>evaluates to the value <c>"ello"</c></p>
        </example>
    </subsubsection>

    <p>The examples above show instance methods being called from String literals. Bear in mind that these methods can be called on any expression that results in an object value, not just literals! In fact, you will more often be calling instance methods from variable expressions. Instance method calls are also often composed with other instance method calls to form more complex expressions, just as we've done with static method calls and operators in previous examples. </p>
    <example>
        <title>Find the name that starts with a capital J</title>
<program language="java"><input>var names = "Mary. Sam. Joey. Abigail.";
var namesStartingAtJ = names.substring(names.indexOf('J'));
var endOfName = namesStartingAtJ.indexOf('.');
var nameStartingWithJ = namesStartingAtJ.substring(0, endOfName);
</input></program>
        <p>In a String listing several capitalized names ending in periods, this code locates and isolates the first name that begins with a J. After each of the four statements are executed, the variable <c>nameStartingWithJ</c> will contain the value <c>"Joey"</c>.</p>
    </example>

</subsection>


    <subsection><title>String Escapes</title>
        <p>There are also some special values that strings (and characters) can hold, such as new lines (a character representing that the cursor drops to the next line), tabs (a character represeting that the tab key was pressed), and so on. These are insterted in to string (and character) literals by including a backslash (called an escape) before a special code. These special characters are interpreted when we print out strings. For example, consider the following print statement:
        </p>
        <program language="java"><input>print("A tab is \n\ta quite simple way \n\t\tto advance");</input></program>

        <p>...prints the following haiku to the console:</p>

<console><output>
A tab is
a quite simple way
to advance
</output></console
        <p>It is important to note that because back slashes are interpreted as escapes, they can not be used as any other character would be in a string. However, you can include them by escaping them! For instance, the following code:
        </p>

        <program language="java"><input>print("here's a backslash: \\");</input></program>
        <p>prints the following to the standard output:</p>
        <console><output>here's a backslash: \</output></console>
    </subsection>
</section>



<section xml:id="section.references">
        <title>Object References</title>
        <p>
            An important and subtle distinction in dealing with object type variables is that the values they hold are not the objects themselves, but rather <term>references</term> to the objects. In this sense, the <c>null</c> value indicates that a variable is not referencing any object value.
        </p>
        <p>
            This doesn't have particularly important implications when dealing with <term>immutable</term> objects like strings (immutable meaning that the values within the object cannot be changed). However, when we use a <term>mutable</term> object like an array, we need to be careful.
        </p>
        <subsection>
            <title>Copying Object References</title>
            <p>
                If you have a variable of type <c>int</c> and copy its value to another variable, you can expect that the value is truly copied. For example:

<program language="java"><input>
int x = 5;
int y = x;
x = 10;
</input></program>

                Tracing through this example, the value 5 was first assigned to x, then copied from x to y. Thus, when the value 10 is assigned to x on the last line, the copy of the value 5 held by y remains. Evaluating y would still yield the value 5.

                However, consider the following code:

<program language="java"><input>
int[] x = new int[] {5};
int[] y = x;
x[0] = 10;
</input></program>

                What would y[0] be? In this case, it would also be 10. Tracing through this example, in the first line, an array is created holding just one value, 5, and a reference to this array object is stored in the variable x. Next, the reference to this object is copied from x and stored in y. That is, both x and y are holding references to the same object! The third line changes the value inside of this array, meaning that both x and y are now referencing an array that contains the value 10!

            </p>
        </subsection>
        <subsection>
            <title>Methods with Side Effects</title>
            <p>
                In prior sections we've developed methods that take some kind of input, perform some calculations on the input, and produce an output without affecting the values that were passed in. Consider the following code:

<program language="java"><input>
int x = 5;
int y = 10;
System.out.println(Math.max(x, y));
System.out.println(x);
System.out.println(y);
</input></program>

                This code will print the values 10, 5, and 10 on three separate lines. In particular, we can rest assured that Math.max has no impact on the values that x and y hold. This is because Math.max has no <term>side effects</term>; that is, it does not have any impact on any part of a program calling it (other than its own local variables).
              </p>
              <p>
                This is not true of every method. For example, calling <c>System.out.println()</c> modifies the global state of the program, since it writes to standard output.
              </p>
              <p>
                Consider the following method:

<program language="java"><input>
void clearArray(int[] arr) {
    for(int i=0; i &lt; arr.length; i++) {
      arr[i] = 0;
    }
}
</input></program>
                    Note that the method above has no return value. It modifies the state of an array value that is passed in. This is another example of a potentially useful side effect. Clearly not all side effects are bad, but inadvertent or unexpected side effects are the source of many confusing and troublesome bugs in more complex programs.
            </p>
        </subsection>
    </section>
    
    
    
<section xml:id="section.characters">
    <info>
        <title>The Character Primitive Data Type</title>
    </info>
    <p>A character is essentially another type of numeric primitive, but with a special purpose. In order to work with textual data on a computer (such as the letters you're reading right now, which were printed off by a computer), each letter (and also other symbols such as punctuation, numbers, etc) are each given a special code number.</p>
    <p>Characters are a primitive type in Java, and the name of the type is <c>char</c>. Thus, just like <c>int</c> and <c>double</c>, you can create a variable of type <c>char</c>:
    </p>

<program language="java"><input>
char letterGrade;
</input></program>

  <p>There is also a special format for character literals. You can surround a character with single-quotes and Java will interpret that as a literal character value. For instance:</p>

<program language="java"><input>
letterGrade = 'A';
</input></program>

<p>Since Java was designed to work on any available computing platform, naturally it should also support any language as well. Thus, the standard used for the characters in Java include codes not only for the letters used in English, but also all other natural languages (including those with many characters, such as Japanese)! This system is called Unicode:
    <uri>https://unicode.org/</uri></p>


<p>The actual codes used for each character in Java can be looked up on the UTF-8 chart here: <uri>https://www.unicode.org/charts/</uri>  Note that you can convert between the character codes and character literals by casting them back and forth to other integer types. For example, the following expression: <program language="java"><input>(int)'a'</input></program> will evaluate to the integer value <c>97</c>, which was designated for this character in unicode. The rest of the lower-case characters in the basic latin alphabet are assigned to each of the following integers, so similarly evaluating the expression: <program language="java"><input>(int)'b'</input></program> will evaluate to <c>98</c></p>


    <subsection>
        <title>Methods for Characters</title>
        <p>Just as with mathematical functions, there are also some <em>built in</em> methods for working with characters. You can make them available in the REPL by typing in the following statement:

<program language="java"><input>
import static java.lang.Character.*;
</input></program>

            A couple important ones are summarized below:

        <dl>
            <!-- these will need to be covered after booleans are
            <li>
                <p><c>boolean isDigit(char)</c> - Takes a character as input and returns a boolean indicating whether or not it is a digit (0-9). </p>
            </li>
            <li>
                <p><c>boolean isLetter(char)</c> - Takes a character as input and returns a boolean indicating whether or not it is a letter (a-z or A-Z). </p>
            </li>
            <li>
                <p><c>boolean isUpperCase(char)</c> - Takes a character as input and returns a boolean indicating whether or not it is a upper-case letter (A-Z). </p>
            </li>
            <li>
                <p><c>boolean isLowerCase(char)</c> - Takes a character as input and returns a boolean indicating whether or not it is a lower-case letter (a-z)</p>
            </li>
            -->
            <li>
                <p><c>char toUpperCase(char)</c> - Takes a character as input and returns that character in upper-case (or leaves it alone if it was already upper-case)</p>
            </li>
            <li>
                <p><c>char toLowerCase(char)</c> - Takes a character as input and returns that character in lower-case (or leaves it alone if it was already lower-case)</p>
            </li>
        </dl>
    </p>
        <!-- this will need to be covered after booleans are
        -        <p>Executing the following code:</p>
-
-    <program language="java"><input>
-char c = 'A';
-if(Character.isUpperCase(c)) {
-  c = 'a';
-}
-    </input></program>
-
-    <p>would result in textit{c} holding the value 'a' at the end.  The following code would also produce the same result:
-    </p>
-
-    <program language="java"><input>
-char c = 'A';
-c = Character.toLowerCase(c);
-    </input></program>
-->
    </subsection>
</section>



<section xml:id="section.arrays">
    <info>
        <title>Arrays</title>
    </info>

    <p>
Strings are a collection of characters, but we haven't yet seen a way to handle a collection of other types of values. Arrays allow Java programmers to create collections of values of an arbitrary type.
    </p>

    <subsection>
        <title>The Array Type</title>
        <p> Arrays themselves are a type of data, but are parameterized by the type of data they hold (that is to say, there are many 'array types' and each is distinguished by the type of data held by an array of that type). Values in an array can have any type, but they must all have the <em>same type</em> as each other.
        </p>
        <p> The syntax for an array type has two parts: the type of data held by the array, and a pair of square brackets indicating an array type. For example, the type <em>array of integers</em> would be written: <c>int[]</c>
        </p>
        <p> A variable named <c>arr</c> that could hold an array of integers is defined as follows:
            <program language="java"><input>int[] arr;</input></program>
        </p>
    </subsection>
    <subsection>
        <title>Creating Array Values</title>
        <p>Like strings, arrays are object types. Thus, variables with array types can be null:

          <program language="java"><input>int[] arr = null;</input></program>

            We also create array objects with the <c>new</c> keyword, although the syntax is a little different than it is for other constructor calls. Square brackets are used instead of parentheses and the size of the array is provided within the square brackets. The size is constant and cannot be changed over the lifetime of the array object you create. For example, the following code initializes <c>arr</c> to contain an array of 5 integers:

          <program language="java"><input>int[] arr = new int[5];</input></program>

            Each of the integers in the array <c>arr</c> are initialized to zero in the previous example. However, we can initialize them to hold arbitrary values by enumerating those values within curly braces instead of providing the length of the array. For example, the following code initializes <c>arr</c> to hold the values 1 through 10:


          <program language="java"><input>int[] arr = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</input></program>
        </p>
    </subsection>
    <subsection>
        <title>Operations on Arrays</title>
        <subsubsection>
            <title>Length of an Array</title>
            <p>
                The first operation to consider on arrays is how to determine the length of an array. This is similar to determining the length of a string, but instead of calling a method, the <c>length</c> field is accessed instead. For example, assuming the most recent definition of <c>arr</c>, the following expression will evaluate to <c>10</c>:

          <program language="java"><input>
                arr.length
          </input></program>

                It is a very common mistake to include parentheses at the end of <c>length</c> for an array or to leave off parentheses at the end of <c>length</c> for a string because of this unfortunate inconsistency.
            </p>
        </subsubsection>
        <subsubsection>
            <title>Accessing an Array</title>
            <p> The most important operation on arrays is retrieving a value from an array. This is very similar to the <c>charAt</c> instance method we used with strings, but instead of calling a method, square brackets following an array value indicate the index of the value to be retrieved. For example, assuming the most recent definition of <c>arr</c>, the following expression will evaluate to <c>1</c>:

<program language="java"><input>arr[0]</input></program>

                Note that the first index of an array is 0, just as with strings.</p>
        </subsubsection>
        <subsubsection>
            <title>Modifying an Array</title>
            <p>Though the size of an array can't change, the values it contains can. Think of an indexed array (an array value with an index following it in square brackets) as any other variable. In addition to evaluating it like a variable expression (above), we can also use it in an assignment statement. For example, the following statement will assign the value <c>100</c> to the first position in the array <c>arr</c>:
<program language="java"><input>arr[0] = 100;</input></program>
                Following this assignment statement, the following expression will evaluate to <c>100</c>:

          <program language="java"><input>arr[0]</input></program>
                      </p>
        </subsubsection>
        <subsubsection>
            <title>Iterating through an Array</title>
            <p>
                For loops are a very convenient way to process each element of an array. For example, the following code initializes <c>arr</c> to the values 1 through 10, but can be easily modified to have any upper limit:

<program language="java"><input>
int size = 10;
int[] arr = new int[size];
for(int i=0; i&lt;arr.length; i++) {
    arr[i] = (i + 1);
}
</input></program>
        </p>
        </subsubsection>
    </subsection>
</section>




<section xml:id="ex.classes">
    <title>Basic Class Definitions</title>

    <p>Every object type has a class definition associated with it, but classes in Java are also used for other special purposes, such as creating a collection of static methods (for example, the Math class) or for creating a Java application. Classes are the primary definition you'll find in a typical Java source-code file. These files end with the extension .java (rather than .txt or .jsh). 
    </p>
    <subsection>
        <title>Class and Static Method Definition Syntax</title>
        <p>A class definition begins with the keyword <c>class</c>, followed by the class name, and then a pair of curly braces. For example, here is a very simple class definition:
        </p>
<program language="java"><input>
<xi:include href="../../examples/code/simple-class.jsh" parse="text"/>
</input></program>
        <p>A Java file must contain one class designated as public using the <c>public</c> keyword before the class definition. It's also important to note that the filename must match the name of the public class, with <em>.java</em> at the end (similar to how an HTML file has <em>.html</em> at the end). For example, if we were to produce a Java file called <em>ExampleClass.java</em>, it could have the following as its contents:
        </p>

        <program language="java"><input><xi:include href="../../examples/code/ExampleClass.java" parse="text"/></input></program>
        <p>Inside of these curly braces is the class body in which its <term>members</term> are defined. Class members include method definitions, so we can include any of the method definitions we've been developing. If we make these methods static by including the <c>static</c> keyword before the method definition, we can use them like any other static method (such as <c>max</c> in the <c>Math</c> class). For instance, consider the following modification of the class definition above:
        </p>
      <program language="java"><input><xi:include href="../../examples/code/ExampleClassWithStaticMethod.java" parse="text"/></input></program>
        <p>Any other Java code we write, even in another file, could access this method as follows:
        </p>
<program language="java"><input>
ExampleClassWithStaticMethod.sayHello();
</input></program>
  <p>And in JShell, we could first use an import and then omit the class name when calling the method:
  </p>
<program language="java"><input>
import static ExampleClassWithStaticMethod.sayHello;
sayHello();
</input></program>
<p>If we want to use import statements in a Java file, they must all come before the class definitions (unlike JShell, where we could use import statements at any time). For example, if we want to use the <c>min</c> from the <c>Math</c> class in a method inside a class we define, we could import it at the top of the file:
</p>
<program language="java"><input>
import static java.lang.Math.min;

public class ExampleClassWithImport {
  public int getValidGrade(int rawGrade) {
    return min(100, rawGrade);
  }
}
</input></program>
    </subsection>
    <subsection>
        <title>Static Fields</title>
        <p>Methods aren't the only members we can add to a class. Variables can also be members, in which case they are called <term>fields</term>. For example, we can create a variable called <c>greeting</c> to hold the message we use in the <c>sayHello</c> method. This allows us to more easily maintain consistency with other methods that greet the user in other ways. <c>greeting</c> must also be declared static to be used as a general purpose method:
        </p>
        <program language="java"><input><xi:include href="../../examples/code/ClassWithMultipleStaticMethods.java" parse="text"/></input></program>
    </subsection>
    <subsection>
        <title>Scope of Fields</title>
        <p>Note that the variable <c>greeting</c> in the previous example is accessible in both of the static methods in the class. That is because the <term>scope</term> of the variable is the entire class definition body. Note that unlike other scope-limited variables, we can access the static scope of a class by giving the class name and following it with the dot operator:

<program language="java"><input>
ClassWithMultipleStaticMethods.sayHello();
ClassWithMultipleStaticMethods.sayHelloEmphatically();
</input></program>
        </p>

        <subsubsection>
            <title>Constants</title>
            <p>Because <c>greeting</c> is a member of the class, just like the <c>sayHello</c> method, it can be accessed from outside of the class as well. That means that the greeting could be modified from outside the class, such as in the following example:
            </p>

<program language="java"><input>
ClassWithMultipleStaticMethods.greeting = "Hey Jerk";
</input></program>

            <p>If a field is never meant to be altered, it should be made in to a <term>constant</term> by using the <c>final</c> keyword in its definition. Here is the updated definition of the running example that prevents any changes to the greeting field:
            </p>

          <program language="java"><input><xi:include href="../../examples/code/ClassWithConstant.java" parse="text"/></input></program>

        </subsubsection>
    </subsection>
</section>


<section xml:id="section.algorithms">
    <info>
        <title>Algorithms</title>
    </info>
    
    <p> 
        <termdef xml:id="term.algorithm">
            An <term>Algorithm</term> is a list of abstract instructions for solving a problem.
        </termdef>
        These instructions need not be computer codes -- an algorithm, as a concept, transcends any one particular programming language.</p>
    
    <p>Algorithms are often used to describe how to perform a complex mathematical operation by breaking it down in to a number of smaller steps. Though algorithms are not limited to manipulating numbers, some simple numerical examples work well to get the idea across.
    </p>
    
    <xi:include href="../../examples/average-algorithm.xml" parse="xml"/>
    
    <p>In this course you will write many computer programs in Java that implement algorithms. However, before we make that leap, we'll first learn about the basic building blocks of a Java program and weave them together to implement the steps in abstract algorithms.
    </p>
    
</section>



<section xml:id="section.style">
    <info>
        <title>Style</title>
    </info>

<p>Now that we're developing more complex code, it's important to take a step back and consider what aspects of the code are easier to understand or more aesthetically pleasing. This is important for a very practical reason: it's hard to develop, edit, or correct code that is difficult to read and understand. Thus there are common style conventions that should be followed while developing Java code.
</p>
    <subsection>
        <title>Block Indentation</title>

        <p>You've now seen two examples of a <em>block</em> in Java. <c>if</c> statements and method definitions both involved curly braces being opened around a series of statements. Every time you open a new block (that is, you open a curly brace), you should indent all statements within that block. Typically only 2 spaces are used rather than a full tab, since that block may contain another <em>nested</em> block, and so on, and using tabs can quickly lead to long lines and horizontal scrolling. Indenting helps you visually recognize what blocks each statement belong to. Thus, while reading a Java program, you can quickly skip over a block of code if you're not particularly interested in it.
        </p>
        <p>
            It's a fairly standard rule that you have no more than one statement on a line and always use a full line for a closing curly brace of a block, but there is some debate over whether you should open a curly brace for a block on the same line as an if statement or a method header, or whether you should open it on its own line. For instance:
        </p>
<program language="java"><input>
int addStuff(int x, int y) {
  return x + y;
}
</input></program>

        <p>and also</p>

<program language="java"><input>
int addStuff(int x, int y)
{
  return x + y;
}
</input></program>

        <p>are both considered good style by many. Mostly it's important that you're consistent with your choice on where to place the opening brace. In this book, we'll consistently use the style of the first example because that's the way the author was raised (and by extension, also now you).
        </p>
    </subsection>


    <subsection>
        <title>Block Comments</title>

    <p>At times a portion of your code will require a more significant explanation spanning multiple lines. Rather than beginning each of these lines with a double slash for an end-of-line comment, it may be preferable to designate a larger portion of your code for comments.</p>

<p>    Block comments are often used for these larger, more descriptive comments. To begin a block comment, type /* and all of the code, including newlines, will be considered a comment up to the closing */.</p>

<p>Another use of block comments is to temporarily <term>comment out</term> a portion of your code if you don't want it to run while you test your code but you also don't want to permenantly delete it. This can be helpful when debugging your more complicated programs. </p>
    </section>

    <section>
        <title>Javadoc Comments</title>
    <p>A special type of block comment is a <term>javadoc comment</term>. These comments come before each method definition and describe in detail what the method does, including the roles of its parameters and a description of the method's return value (if any). Javadoc comments begin with a <c>/**</c> instead of a <c>/*</c>
    </p>
        <p>
    Javadoc comments also have a special syntax for describing the parameters and return values. Within the Javadoc comment, a line beginning with <c>@return</c> will describe the return value and a line beginning with <c>@param</c> followed by the name of the parameter will describe one of the parameters. If you document your parameters in this way, you can also refer to your parameters in the rest of the comment with the following: <c>@code parameterName</c> where <c>parameterName</c> is the name of your parameter.
        </p>
        <p>
    If you use the Javadoc comment format, HTML documentation for your code can be automatically generated. In fact, the API documentation pages we've used previously were all automatically generated from javadoc comments in the API source code!
        </p>

        <example>
            The following method definition has an appropriate Javadoc comment preceding it:
        <program language="java"><input>
<xi:include href="../../examples/code/javadoc-method-basic.jsh" parse="text"/>
        </input></program>
        </example>

  </subsection>
</section>

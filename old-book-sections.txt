


<section xml:id="section.scope">
    <info>
        <title>Scope</title>
    </info>
    <p>
      When writing larger programs, you will find that some variable definitions will only work as you expect them to in some parts of the program. This is because variable definitions are bound to a <term>scope</term> within the program. </p>

    <p>
      In Java, variable scopes are limited to the code blocks they're defined in. The extent of a code block is everything in between the block's opening and closing curly braces. Once a variable is defined inside the scope of a code block, it can be referenced on any succeeding line, including those in nested code blocks (additional code blocks defined inside of the code block in question).
    </p>


    <example  xml:id="ex.basic-scope"
        >
        <title>Basic Scope Example</title>
        <p>Considering the following code:
<programlisting>
{
  var x = 5;
  {
    var y = x + 5;
  }
  System.out.println(x);
  System.out.println(y);  // error, y is not defined in this scope
}
System.out.println(x);  // error, x is not defined in this scope
</programlisting>

      Both of the commented-out print statements would be errors since the variables they reference are defined in a different scope. Note that the first print statement is valid because <c>x</c> is defined in the same scope as that statement.
        </p>
        <p>
          Another important thing to note is that the statement in the inner-most scope can legally access the variable x. If a block of code is opened inside another block of code, it will inherit all the variable definitions of its enclosing scope.
        </p>
    </example>


    <p>
      Blocks of code comprising the bodies of conditional statements, loops, and method definitions. Variables defined in the header of a for loop are constrained to the scope of the body of the for loop.
    </p>


    <example  xml:id="ex.for-loop-error"
        >
        <title>Common Scope Error with For Loops</title>
        <p>Considering the following code:
<programlisting>
for(int x = 1; x &lt;= 10; x = x + 1);
    System.out.println(x);
</programlisting>

      At first glance, it appears this code will print out the numbers <c>1</c> through <c>10</c>, however, there is a semi-colon at the end of the first line. When omitting curly braces, the body of a for loop will consist of a statement immediately following the loop header. Since a semicolon follows the loop header, it counts as the single statement, meaning the print statement on the second line is not part of the for loop's body. Thus, the reference to the variable <c>x</c> is not in the correct scope and will be caught as a syntax error.
        </p>
    </example>
</section>






<section xml:id="section.conditional-expressions">
    <info>
        <title>Conditional Expressions</title>
        <remark>Prerequisites: expressions</remark>
    </info>

    <p>
      Boolean expressions evaluate to one of two values: <c>true</c> or <c>false</c>. What if the programmer wanted an expression like this to evaluate to one of two other values? For example, what if the program was answering a question about whether it was hot outside and the user expected <c>"yes"</c> or <c>"no"</c> to be printed? A <term>conditional expression</term> builds on a boolean expression to provide this flexibility.
    </p>

    <figure>
    	<title>conditional-expression</title>
        <caption>Anatomy of a Conditional Expression</caption>
        <image source="figures/conditional-expression.png"/>
    </figure>

    <p> Conditional expressions use two operators in conjunction: a question mark (?) and a colon (:). These operators sit between three other expressions. These five parts of a conditional expression come in this order: a boolean expression, followed by a question mark, followed by an expression that will be evaluated if the initial boolean expression is true, followed by a colon, followed by an expression that will be evaluated if the initial boolean expression is false.
    For example, consider the following conditional expression:
    </p>
<programlisting>
    5 > 10 ? 30 : 40
</programlisting>
<p>
    This expression evaluates to the value 40. Since the initial boolean expression evaluates
    to false, the expression following the colon is evaluated. The middle expression is ignored
    in this case. If we changed the comparison operator to &lt;
    the whole conditional expression would have evaluated to 30 instead.
</p>
<p>
    Here's another example that would evaluate to the maximum of two integer variables x and y:
</p>

<programlisting>
    x > y ? x : y
</programlisting>

</section>



<section xml:id="section.comparison-operators">
    <info>
        <title>Comparison Operators</title>
    </info>

        <p> The boolean type is useful for answering <em>yes</em> or
                <em>no</em> questions, such as <em>is 2 equal to 1 + 1?</em>
            We can ask these types of questions with comparison operators. </p><p>
            The comparison operators are binary operators, just like the arithmetic operators from prior sections. However, they operate over values of any type (instead of numeric values), and the evaluate to a boolean value (instead of a numeric value). For example, <c>==</c> is the comparison operator. It determines whether two values are the same or not. So, to answer the question we posed in the last paragraph, we could use an expression like this:

<programlisting>
(1 + 1) == 2
</programlisting>

            If you type this in to the REPL, it will evaluate to <c>true</c>. Note that the parentheses are not necessary, either. <c>+</c> will be evaluated before any comparison operators will be. There are several other comparison operators that will be useful to us, summarized below:

            <dl>
                <li>
                    <p><c>!=</c> Not equal to</p>
                </li>
                <li>
                    <p><c>&gt;</c> greater than</p>
                </li>
                <li>
                    <p><c>&lt;</c> less than</p>
                </li>
                <li>
                    <p><c>&gt;=</c> greater than or equal to</p>
                </li>
                <li>
                    <p><c>&lt;=</c> less than or equal to</p>
                </li>
            </dl>
        </p>
        <p> For example, the expression <programlisting>4 &lt; 3 + 3</programlisting> would
            evaluate to <c>true</c>. </p>

            <p>
              Note that the <c>==</c> operator can not be used to compare the contents of two objects. The <c>==</c> operator will determine if two object references are equal (references are covered in more detail in another section). If you wish to compare the contents of two objects (such as to determine if two strings contain the same characters), use the <c>equals</c> instance method of one of the objects and pass the other in as an argument.
            </p>
            <p>
              For example, to check if an object stored in the variable <c>message1</c> has the same content as the object stored in the variable <c>message2</c>, the following expression would work: <programlisting>message1.equals(message2)</programlisting> Reversing the order would also work (assuming that neither variable holds the <c>null</c> value).
          </p>
</section>



<section xml:id="section.boolean-operators">
    <info>
        <title>Boolean Operators</title>
    </info>

        <p>
            There are also operators that work strictly over boolean values, just as the arithmetic operators we used last week worked strictly over numeric values. These are called <term>boolean operators</term>. They operate over one or two boolean values and evaluate to another boolean value.  These operations are quite simple but form the basis for what is known as <term>boolean algebra</term>.
        </p><p> The first operator we'll consider is the and operator: <c>&amp;&amp;</c>. This is a
            boolean operator that evaluates to <c>true</c> only when both the left and
            right operands also evaluate to <c>true</c>. For example:
            <programlisting>
true &amp;&amp; false
</programlisting> evaluates to
                <c>false</c>, since the right-hand operand is false. However:
            <programlisting>
true &amp;&amp; true
</programlisting> evaluates to
                <c>true</c>, since both operands are true. </p><p>
            The next operator we'll consider is the or operator: <c>||</c> It is similar to the and operator, but it evaluates to <c>true</c> when either of the operands are true. Put another way, this operator will only evaluate to <c>false</c> when both of its operands evaluate to <c>false</c>. For example, if you replaced <c>&amp;&amp;</c> with <c>||</c> in both of the last two expressions, they would both evaluate to <c>true</c>.
        </p><p> The last boolean operator we'll consider is unique in that it's a unary operator. Recall that
            this means it has only one operand. It is called the not operator: <c>!</c> This
            operator simply reverses the boolean value of its operand. For example:
            <programlisting>
!false
</programlisting> evaluates to <c>true</c>. Note
            that all of these operators can be combined and nested in sub expressions. For example,
            the following expression evaluates to <c>true</c>:
            <programlisting>
!((false &amp;&amp; false) || false)
</programlisting> These operators
            also have an order of precedence: <c>!</c>, <c>&amp;&amp;</c>, <c>||</c>
        </p>

        <p>
          Another feature of boolean operators that you should be mindful of is called <term>short circuiting</term>. The operands of <c>&amp;&amp;</c> and <c>||</c> are evaluated in order from left to right. If the left operand evaluates to <c>false</c> for  <c>&amp;&amp;</c>  or if the left operand evaluates to <c>true</c> for  <c>||</c>, the right operand is never evaluated. This is because it doesn't matter what value this operand evaluates to --  a <c>&amp;&amp;</c> expression would evaluate to <c>false</c> and a <c>||</c> expression would evaluate to <c>true</c> in these scenarios regardless of what value the right operand evalutes to.
        </p>
        <p>
          For the most part, this just means that your programs will run a bit more efficiently, since only have of the work needs to be done to evaluate these expressions at times. However, if an error or a side effect occurs while evaluating the right operand, it is important for the programmer to know that it will not occur when the left operand is not evaluated due to short circuiting. The programmer can also take advantage of this. For example, consider a scenario where the variable <c>students</c> is the number of students in a class and the variable <c>cupcakes</c> is the number of cupcakes the instructor brought with them. If we want to determine whether there are enough cupcakes for each student to have at least 2, we could use the following boolean expression:
          <programlisting>cupcakes / students &gt;= 2</programlisting>
          However, if by some mistake we used this expression for a class with no students in it, we would get a division by zero error instead of <c>true</c>. The latter would be preferred if we simply wanted to know whether the enough cupcakes were baked. Thus, we could instead use the following expression:
          <programlisting>students > 0 &amp;&amp; cupcakes / students &gt;= 2</programlisting>
          In this case, if <c>students</c> is zero, the left operand to <c>&amp;&amp;</c> would evaluate to false, and the right operand would be ignored, avoiding the division by zero error.
        </p>
</section>


<section xml:id="section.statements">
    <info>
        <title>Statements</title>
    </info>
    <p>
        <termdef xml:id="term.statement">
            A <term>statement</term> is essentially a single instruction.
        </termdef>
        This is a fairly abstract definition, but statements serve many purposes in imperative programming languages like Java and can embody simple or complex instructions. The main difference between a statement and what we've seen with expressions is that statements don't evaluate to some value. Instead, they <em>do something</em> to the state of the computing environment. For instance, they may alter the value of a variable or print something to the screen. These actions are referred to as <term>side effects</term> and are the heart of imperative programming.
    </p>
    <p>
        Syntactically, statements will vary, but for the most part end with a semicolon (similar to the period at the end of a sentence in English).  A very simple statement consists of an expression followed by semicolon. For example, the hello world example we started with mostly fits this pattern:
        <programlisting>System.out.println("Hello World!");</programlisting>
        This is essentially a method call expression (though it involves a few other concepts we'll explore soon) with a semicolon at the end. Note that the argument is not a character literal -- the double quotes indicate that it is a String, which is a sequence of several characters (strings are covered in much more depth in another section). </p>
      <p>When we call this method, we're not concerned with what value it returns, but rather what it <em>does</em>. In this case, the statement prints the welcome message to the screen (an example of a side effect).</p>
</section>


<section xml:id="section.method-call-statements">
    <info>
        <title>Method Call Statements</title>
    </info>


    <p>Not every method will need to return a value. Some methods simply perform some side effects (that is, they alter the global state of the program in some way), and exit, yielding no return value. These methods are called <term>void methods</term> in that their return value is void (that is, there is no value at all). </p>

    <p>Method call statements are very similar to method call expressions. The only difference is that they are the entire statement and end in a semicolon. For more information about how to make a method call, refer to the method call expression section</p>

    <example>
      <title>Printing a Message to the Screen</title>
      <p>Thus far, we've received messages back from the REPL each time we evaluate an expression, but perhaps we would like a message to be delivered somewhere during the execution of our program. Many <em>text-based applications</em> interact with their users solely through messages printed to a console (such as the REPL itself). In the case of jshell, standard output is simply the jshell screen, so any messages you print while using jshell will show up there.</p>

      <p>The method we will use to print to standard output is unfortunately (and infamously) somewhat complicated looking, but JShell does allow to access it in a more simple way. If you start up JShell with the <c>-startup PRINTING</c> argument, the print method will be available to you to call to print a message to the screen. Below is an example of how you could start JShell from a system command prompt with this option and use the print method to send a greeting:</p>
<console>
bash-3.2$ jshell -startup PRINTING
|  Welcome to JShell -- Version 10.0.1
|  For an introduction type: /help intro

<prompt>jshell> </prompt><input>print("Hello World!")</input>
Hello World!
</console>
    </example>
</section>


<section xml:id="section.declaration-statements">
    <info>
        <title>Declaration Statements</title>
    </info>
    
    <p>Declaration statements are used to define new variables. In contrast to the automatically generated variables we saw when evaluating expressions with the REPL, declaration statements allow us to create variables with any legal name we wish. Variable names must be legal <term>Java identifiers</term>. 
    </p>
    <p>There are several places you'll see identifiers in Java. Identifiers can simply be thought of as the names of things in a Java program. There are some rules about which names are legal, since some names might be interpreted as instructions or other parts of the program if they're not written properly. Here are the Java identifier rules:</p>

    <ul>
        <li><p>Every Java identifier must begin with either a letter, a dollar sign, or an underscore.</p></li>
        <li><p>Java identifiers cannot contain white space (spaces, new lines, tabs), but can contain any other characters.</p> </li>
        <li><p>Java identifiers cannot be a reserved word (you can find a list of these online or in the textbook)</p>.</li>
    </ul>

        <p>If you deviate from those rules, you end up with an error. For example, Identifiers can contain digits, but they cannot begin with one. Thus <c>x5</c> is a legal variable name, <c>5x</c> is not. </p>

        <p>Note that the variable <c>reallylongvariablename</c> is legal, but is also somewhat difficult to read. The same identifier might appear dozens of times in a program and a long one such as this will become tedious for the programmer to read and type! For this reason, there are <term>conventions</term> in Java that dictate the proper way to name variables. <c>reallylongvariablename</c> is not an error, but it does break a variable naming convention in Java known as called <term>camel case</term>. In camel case, you don't include spaces between words, but you capitalize each successive word. We must do this for identifiers consisting of multiple words since spaces are not allowed in identifiers. Furthermore, for variable names in Java, by convention the first word is not capitalized. Considering these conventions, a proper identifier we could use as a variable name would be <c>reallyLongVariableName</c>. Notice that this is a bit easier to read?
</p>
     <p>All conscientious programmers also try to use identifiers that are meaningful and help explain the purpose of a definition. For example, if you want to average the values of three exam scores, you might call each of the variables holding the exam scores <c>exam1</c>, <c>exam2</c>, and <c>exam3</c> instead of <c>x</c>, <c>y</c>, and <c>z</c>, and you might call the variable holding the average <c>averageExamScore</c> or perhaps simply <c>average</c>.
        </p>

    <p>
      In order to use a variable in Java, you must declare that it exists using a <term>declaration statement</term>. 
        
        <figure>
            <title>declaration-statement</title>
            <caption>Anatomy of a Declaration Statement</caption>
            <image source="figures/declaration-statement.png"/>
        </figure>
  
      Java is known as a statically typed language, which means that when we declare variables, we must also declare what type of value they hold. The first element of a declaration statement is the type of data the variable will hold, and the second is the identifier (variable name). 
    </p>
    
    <xi:include href="../../examples/declaration-default-value.xml"/>
  
</section>


<section xml:id="section.assignment-statements">
    <info>
        <title>Assignment Statements</title>
    </info>
    
    <p>The main difference between variables in programming and variables you've used in math classes is that, rather than trying to determine what value the variable represents, you get to dictate what that value is yourself. In Java, this is done using an assignment statement. The automatically generated variables from JShell ($1, $2, etc) aren't intended to be changed, but the variables we declare ourselves are!
    </p>
    
    <p>
        Below is a syntax diagram for a typical assignment statement:
   
        <figure>
            <title>assignment-statement</title>
            <caption>Anatomy of an Assignment Statement</caption>
            <image source="figures/assignment-statement.png"/>
        </figure>
   
        There are two distinct parts to an assignment statement: on the left is an identifier for the variable you want to make an assignment to, and on the right is an expression which yields the value you want to assign to the variable. 
    </p>
    <p>This syntax may be a little confusing since it uses the equals operator despite the fact that this is not an equation! This is one situation where the semantics (meaning) of Java syntax diverges from what you might be accustomed to from algebra. Rather than trying to determine what the <c>x</c>'s value should be, this statement makes <c>x</c> equal to <c>5</c>.
    </p>
    
    
    
    <xi:include href="../../examples/assignment-simple.xml"/>
    
    <p> 
        <termdef xml:id="term.initialization">
            When a variable is assigned its first (initial) value, we say that the variable has been <term>initialized</term>.
        </termdef>
        Variables must be initialized before they can be used in another part of a program, and variables must be declared before they can be initialized. In the previous example, two statements were used for these two tasks, respectively. However variables can be declared and initialized in a single statement, which saves the programmer some typing. These combination statements take the following form:
        
        <figure>
            <title>initialization-statement</title>
            <caption>Anatomy of an Initialization Statement</caption>
            <image source="figures/initialization-statement.png"/>
        </figure>
        </p>
        <p>It's also not always necessary to provide a type in an initialization statement. Since Java 10 was released, Java will infer the proper type of the variable from the type of the expression used to initialize it. In this case, you can simply use the keyword <c>var</c> rather than a type when declaring and initializing a variable:
        
            <figure>
                <title>initialization-statement-type-inference</title>
                <caption>Anatomy of an Initialization Statement with Type Inference</caption>
                <image source="figures/initialization-statement-type-inference.png"/>
            </figure>
        
        Note that the only difference between this diagram and the previous one is the <c>var</c> keyword in place of the variable type. This is one of several ways that the Java maintainers have recently integrated <term>type inference</term>. When the term type inference is used, it means that the programmer won't need to explicitly name a type of a variable when the proper type is obvious from context. Note that the type is still static (that is, you can't later change the type of the variable). Though either form of these initialization statements are acceptable, type inference has made Java a little less wordy and a little easier on programmers, so as long as you're using a more recent version of Java (in this case, Java 10 or later), the latter syntax is preferred in most cases. 
    </p>
    
    <xi:include href="../../examples/assignment-and-declaration-statement.xml"/>
    
</section>


<section xml:id="section.assignment-shortcuts">
    <info>
        <title>Shortcuts for Common Assignment Statements</title>
    </info>

<p>
You've now no doubt wrote a statement such as the following many times:
</p>

<programlisting>
i = i + 1;
</programlisting>

<p>
This happens so frequently in Java that there are several built-in shortcuts for such statements. For instance, if we simply want to add a value to a variable (rather than replace a value in a variable), we could do so using the <c>+=</c> operator. Thus, an equivalent version of the code above is the following:
</p>

<programlisting>
i += 1;
</programlisting>

<p>
We could also add <c>2</c> to the value of <c>i</c> the same way, or any other value we want to increment it by. Similarly, we could subtract that value from <c>i</c>  with the <c>-=</c> operator. Each of the other arithmetic operators has a similar shortcut.
</p>
<p>
Beyond these shortcuts, it's also very common to simply add <c>1</c> to a variable, so there is a second shortcut that just adds <c>1</c>:
</p>

<programlisting>
i++;
</programlisting>

<p>
Note that this shortcut can be used to simplify the string iteration example considerably, since it uses a somewhat long variable name:
</p>

<programlisting>
<xi:include href="../../examples/code/count-l-in-hello.jsh" parse="text"/>
</programlisting>

<p>
If you've ever heard of the programming language C++ and wondered why it was named that way, now you know. Similarly, another shortcut exists for subtracting <c>1</c> from a variable.
</p>

<programlisting>
i--;
</programlisting>

<p> Shortcuts exist also for the other arithmetic operators. For example, the following statement will double the value held by the variable <c>i</c>:
<programlisting>
i *= 2;
</programlisting>
</p>

<p> This shortcut also for the concatenation operator. For example, the following statement will concatenate an exclamation mark on to the string held by the variable <c>str</c>:
<programlisting>
str += "!";
</programlisting>
</p>

</section>
<section xml:id="section.while-loops">
    <info>
        <title>While Loops</title>
    </info>

  <p>
While loops are a lot like if statements. In fact, they have a nearly identical syntax. </p>

    <figure>
        <title>while-loop</title>
        <caption>Anatomy of a While Loop</caption>
        <image source="figures/while-loop.png"/>
    </figure>
    
    
    <p>While loops start with the <c>while</c> keyword, and then a boolean expression in parentheses, and then a block of code (a series of statements surrounded by curly braces) or a single statement. The only difference is that when this block of code or single statement completes, program control returns to the beginning of the while loop. Think of it as an if statement that repeats itself indefinitely.
</p><p>
    Now you may be concerned by the word <em>indefinitely</em>, and you should be -- it's a distinct possibility that a while loop can run <em>forever</em>. However, after each <term>iteration</term> of the loop (an iteration is complete after execution reaches the end of the code block), the boolean expression at the front of the while loop is evaluated again. If you wrote the loop correctly, that boolean expression should evaluate to <c>false</c> when you don't want the loop executing anymore. 
</p>
    
    <example><title>Counting with a While Loop</title>
    <p>
The following code will add up the numbers 1 through 10:
</p>
<programlisting>
<xi:include href="../../../examples/code/count-to-ten.jsh" parse="text"/>
</programlisting>
<p>
After the first iteration of the loop, count will increase by 1 and total will increase by 1. Thus, when the boolean expression is evaluated the second time, count will be 1 (and not 0). However, 1 is still less than 10, so the loop will run a second time. After the second iteration, count will increase to 2 and total will increase to 3. Now you might see where this is going. The loop will run 8 more times until count is equal to 11. At that point, count will be greater than 10, so the boolean expression will be false, and the statements inside the block will be skipped. 
</p>    
    </example>
    
</section>


<section xml:id="section.for-loops">
    <info>
        <title>For Loops</title>
    </info>

<p>When writing loops, three components are very commonly included:
    <ul>
        <li>
            <p>Some local variable is declared and initialized, for instance a variable named <c>counter</c> could be initialized to <c>1</c>. </p>
        </li>
        <li>
            <p>That variable is tested as part of the while condition, for instance looping while <c>counter</c> is less than <c>10</c>.
            </p>
        </li>
        <li>
            <p>At the end of each iteration of the loop, the variable is altered in some way, for instance <c>counter</c> could be incremented at the end of each iteration of the loop. </p>
        </li>
    </ul>

Since nearly every while loop that we write contains these three components, and also because they play an important role in determining how the loop executes, Java provides a special syntax called a <c>for</c> loop that simply re-organizes these components to all reside at the front of the loop.
</p>

    <figure>
        <title>for-loop</title>
        <caption>Anatomy of a For Loop</caption>
        <image source="figures/for-loop.png"/>
    </figure>

<p><term>for loops</term> start with the <c>for</c> keyword and a pair of parentheses, just like a while loop, but inside the parentheses is first an expression (ending in a semicolon) that is executed before the loop starts, secondly a boolean expression (the same as the looping condition for the while loop), also ending in a semicolon, and finally a statement that is executed at the end of each loop (typically incrementing a variable). The last statement doesn't have a semicolon following it, but all three should be within the parentheses. The rest is identical to a while loop. </p>

<example><title>Totaling Numbers with a For Loop</title>
<p>Consider the following while loop which adds the numbers between 1 and 10:
</p>

<programlisting>
int total = 0;
int count = 1;
while(count &lt;= 10) {
  total = total + count;
  count = count + 1;
}
</programlisting>

    <p>Here is identical code written as a for loop:</p>

<programlisting>
int total = 0;
for(int count = 1; count &lt;= 10; count = count + 1) {
  total = total + count;
}
</programlisting></example>

    <p>Because code written with while loops and for loops perform the exact same task, we call for loops <term>syntactic sugar</term>, in that it is meant only to help with the look of your code, not the function of your code. Essentially, it is used to improve your coding style.</p>

<example><title>Iterate Through a String</title>
    <p>The following code will print each character of the string <c>message</c>, one character per line:
    </p>
<programlisting>
String message = "hello";
for(int i=0; i &lt; message.length(); i = i + 1) {
  System.out.println(message.charAt(i));
}
</programlisting>
</example>

</section>


<section xml:id="section.for-each">
    <info>
        <title>For-Each Loops</title>
    </info>

<p>While loops used to iterate over an array often looked very similar, so for loops were introduced as a more concise way to handle the task. <term>For-Each Loops</term> were introduced in Java 5 as an even more concise way to deal with these tasks, and are preferred whenever the programmer intends to iterate over each element of an array <em>sequentially</em> (that is, starting with the first, then the second, and so on until the last element).
</p>

    <p>
A for-each loop eliminates the index variable <c>i</c> entirely. Instead, the programmer must define a new variable that will hold a single element of the array through each iteration of the loop. The same keyword <c>for</c> is used. Following the definition of this new variable, the programmer must include a colon (<c>:</c>) and then an expression yielding the array to be iterated over (usually just a variable reference).
    </p>


<example>
    <p>Consider the following array of Strings:</p>

<programlisting>
String[] names = new String[] { "Jane", "Billy", "Susie" };
</programlisting>

<p>A for loop could be used to print each name out:</p>

<programlisting>
for(int i=0; i &lt; names.length; i++) {
    System.out.println(names[i]);
}
</programlisting>

<p>The following for-each loop will perform the exact same task with a little less code, and is a little easier to read and understand:
</p>

<programlisting>
for(String name : names) {
    System.out.println(name);
}
</programlisting>

<p>This makes it easier to use arbitrary expressions that yield arrays. For example, the following code snippet also does the same thing as the previous two, but doesn't require the initial variable definition:
</p>

<programlisting>
for(String name : new String[] { "Jane", "Billy", "Susie" }) {
    System.out.println(name);
}
</programlisting>
</example>
</section>


<section xml:id="section.continue-statements">
    <info>
        <title>Continue Statements</title>
    </info>

        <p>
          <term>continue statements</term> can be used within a loop when the remainder of the loop should not be executed, but the loop should not be terminated as it would be with a <c>break</c> statement. When a <c>continue</c> statement is executed, the enclosing loop will cease executing its current iteration and then resume execution with the next iteration of the loop. Note that, if a <c>continue</c> statement is encountered in a <c>for</c> loop, the update statement will still execute before the next iteration of the loop begins.
        </p>

        <p><c>continue</c> statements are very simple in their syntax. They consist of just a single keyword (<c>continue</c>) followed by a semicolon:
      </p>
      <programlisting>
        continue;
      </programlisting>
        <p>You will use <c>continue</c> statements within an <c>if</c> statement since you will only want to skip the remainder of an iteration of a loop because some other condition that arises. Perhaps the task of the current iteration of the loop is completed early or perhaps an error was encountered that should end the current iteration of the loop but not the entire task the loop is handling. </p>


      <example><title>Validating User Input</title>
        <p>
          Assume there is a method called <c>getUserResponse</c> that allows the user to enter in a numeric value. The following code will request a positive even integer from the user and validate the user's response. If the user provides such a value, it will be added to a running total of these numbers.
        </p>
        <programlisting>
    int total = 0;
    while(true) {
      // get a number from the user
      System.out.print("provide a positive, even number: ");
      x = getUserResponse();

      if(x &lt;= 0) { // ensure user provided a positive number
        System.out.println("Error: enter a positive number.");
        continue;
      }

      if(x % 2 != 0) { // ensure user provided an even number
        System.out.println("Error: enter an even number.");
        continue;
      }

      // add the number to the total
      total = total + x;
      System.out.println("Total is currently " + total);
    }
        </programlisting>
          <p>
            There are two <c>continue</c> statements used in this snippet of code. The first is used when it is detected that the user provided a number that is not positive. The <c>continue</c> statement forces the loop to restart and the user is once again prompted for a valid response. The second <c>continue</c> statement is executed if an odd number is provided by the user. In both cases, the statement that adds the number to the total is skipped if the user breaks either of the rules for proper input. Sample interaction with this snippet of code may look like the example below:
          </p>

<console>
provide a positive, even number: 4
Total is currently 4
provide a positive, even number: 93
Error: enter an even number.
provide a positive, even number: 8
Total is currently 12
provide a positive, even number: -2
Error: enter a positive number.
provide a positive, even number:
</console>
      </example>
</section>


<section xml:id="section.break-statements">
    <info>
        <title>Break Statements</title>
    </info>

    <p>Loops don't need to be terminated only when the loop condition becomes false. A loop can be terminated early by using a <term>break statement</term> inside of the loop. When a <c>break</c> statement is encountered, the enclosing loop will immediately terminate and execution will resume just after the closing brace of the
      loop.
    </p>

    <p><c>break</c> statements are very simple. They consist of just a single keyword (<c>break</c>) followed by a semicolon:
  </p>
  <programlisting>
    break;
  </programlisting>
    <p>You will use <c>break</c> statements within an <c>if</c> statement since you will only want to terminate the loop early because of some other condition that arises. You may want to use a break statement if an error occurs that must be processed. You can also intentionally begin an infinite loop (set the loop condition to <c>true</c>) and use break statements to end the loop. </p>


  <example><title>Searching for Values in an Array</title>
    <p>
      The following code will search through an array <c>arr</c> for the number <c>13</c>:
    </p>
    <programlisting>
int i=0;
for(; i&lt; arr.length; i++) {
  if(arr[i] == 13) {
    break;
  }
}
    </programlisting>
      <p>When this snippet of code completes executing, <c>i</c> will be the index for <c>arr</c> where the value <c>13</c> is located (or it will be <c>arr.length</c> if <c>13</c> doesn't appear in <c>arr</c>).
      </p>
  </example>

</section>


<section xml:id="section.switch-statements">
        <info>
            <title>Switch Statements</title>
        </info>

        <p>If each of the <c>if</c> statements in an if/else chain are simply comparing some expression to one of several literal values, there is a special syntax in Java called a <term>switch</term> statement that can be used instead. In some of these cases, this will be a little easier to read and more efficient.
        </p>


        <p>
            The syntax for switch statements is a little trickier than the other conditional statements we've seen. Following the <c>switch</c> keyword is an expression in parentheses, but it won't be a boolean expression. Instead, it can be any other type of primitive or String value. This value will be compared against a number of literal values inside of the switch statement body, which follows.</p><p>
            The body is contained within a pair of curly braces and consists of a series of <term>case statements</term>. Each case statement begins with the <c>case</c> keyword, followed by the literal value that the resulting value from the original expression at the head of the switch statement will be compared to, and then a colon. Following that will be a series of statements. Curly braces are not necessary.
        </p><p>
            Note that after a case statement is complete, the next case statement will be executed! Unless this is intentional, you must explicitly end the switch statement using a <term>break statement</term>. This is simply the keyword <c>break</c> followed by a semicolon. Break statements are not needed if a return statement is used, since execution of the enclosing method will end at that point anyway.
        </p><p>
            One last important feature of the switch statement syntax is the <term>default case</term> which can handle the case where the value we get back from the initial expression doesn't match any of the literal values in the cases. A switch statement without a default case will simply do nothing. </p>
        <p>There is a special syntax for defining the default case. Default cases look like the other case statements, but they use the keyword <c>default</c> instead of <c>case</c> and are immediately followed by a colon instead of some literal value to compare with.
        </p>

        <example>
            <title>Switching Over Letter-Grade Characters</title>
            <p>A grade book application needs to determine the minimum grade needed for each letter grade. Letter grades will be represented with capital letter characters. This functionality could be developed using an if/else chain:
                </p>

<programlisting>
int getMinimumGrade(char letterGrade) {
  if ( letterGrade == 'A' ) {
    return 90;
  } else if ( letterGrade == 'B' ) {
    return 80;
  } else if ( letterGrade == 'C' ) {
    return 70;
  } else if ( letterGrade == 'D' ) {
    return 60;
  } else {
    return 0;
  }
}
</programlisting>

            <p> However, this is a good opportunity to use a switch statement. The switch statement below takes equivalent action, but will run a little more efficiently and may be a little easier to read and modify:
            </p>

<programlisting>
int getMinimumGrade(char letterGrade) {
  switch(letterGrade) {
    case 'A':
      return 90;
    case 'B':
      return 80;
    case 'C':
      return 70;
    case 'D':
      return 60;
    default:
      return 0;
  }
}
</programlisting>
<p>Note that no break statements are needed in this example since return statements are used in each case.</p>
</example>
    </section>



<section xml:id="section.nesting-if-statements">
        <info>
            <title>Nested If Statements</title>
        </info>

        <p>Any statement can be included in the body of an if statement, which means you can include an if statement inside an if statement! This is called a nested if statement.
        </p>
        <example>
            <title>Nested if Statements to Determine Best Temperature</title>
            <p>
                The following method will return <c>true</c> <em>if</em> the <c>tempaerature</c> (an integer type variable) is between <c>68</c> and <c>72</c>:</p>


            <programlisting>
<xi:include href="../../../examples/code/justRight.jsh" parse="text"/>
</programlisting>
            <p>One thing to note about this example is that there are no <c>else</c> statements. There could be, but they aren't necessary since in all cases they would return <c>false</c>, which is also what the last statement of the method does.
            </p>
            <p>
                Also notice that the nested if block is indented further than the block it is nested in. This is an important style convention that you should follow whenever opening nested blocks of code, not just with nested if statements.
            </p>
        </example>
    </section>



<section xml:id="section.if-statements">
    <info><title>If Statements</title></info>

    <p>
    An if statement is a new kind of statement that will only execute when a certain boolean expression evaluates to true.
    </p>

    <figure>
        <title>simple-if-statement</title>
        <caption>Anatomy of a Simple if Statement</caption>
        <image source="figures/simple-if-statement.png"/>
    </figure>

    <p> If statements start with the keyword <c>if</c>, then a boolean expression (surrounded in parentheses -- the parentheses are necessary), then the statement we want to conditionally execute. For instance, consider the following statements:
    </p>

<programlisting>
    int x = 10;
    int y = 0;

    if (y > x) x = 30;

    if (x > y) y = 20;
</programlisting>

    <p>
        The first if statement does nothing. y is not greater than x at this point, so the assignment statement that follows it (<c>x = 30;</c>) does not execute. The second if statement will set the variable <c>y</c> to the value 20. Since <c>x</c> is greater than <c>y</c>, the statement (<c>y = 20;</c>) will be executed.
    </p><p>
        More than one statement can be conditionally executed in an if statement. In fact, you can include as many as you like by opening up a <term>block</term> of code using curly braces surrounding each of the conditionally executed statements.
    </p>

    <figure>
        <title>if-statement</title>
        <caption>Anatomy of an if Statement with a Block Body</caption>
        <image source="figures/if-statement.png"/>
    </figure>

<programlisting>
if (x > y) {
    x = 30;
    y = 40;
    z = 50;
}
</programlisting>
    <p>
        There are a couple important points to keep in mind about code blocks. First, notice that there is no semicolon at the end of the block of code following the closing curly brace. Even though we say there is an if <em>statement</em> here, the if portion doesn't actually have a semicolon on the end. Including a semicolon following the if portion of this code snippet is actually a common error that can be difficult to debug (the body of the if would always execute in this case and no error message would be given).
    </p>
    <p>
        Another important consideration is style. Note that all of the statements inside of the block are indented. This is an important convention in Java that makes the code much easier to read. Soon you will be including blocks of code inside of blocks of code, and each should be further indented, helping the programmer to see how deeply <term>nested</term> the blocks of code are. Typically each nested statement is indented two spaces. Sometimes a tab or four spaces is used instead, but this can become a problem with larger programs. Whatever choice you make, the most important consideration is that you use consistent indentation throughout your program.
    </p>
</section>


<section xml:id="section.if-else-chains">
        <title>if/else Chains</title>

    <p>When a situation calls for one of two kinds of action, we could use a if statement with an else statement following it. However, if there are more than two actions we might take, we can nest a new if statement inside of each else statement, forming a chain of if / else statements (ending in an else statement with no nested if statement). This way, rather than just two choices in the conditional statement, this if/else structure allows us to have 3 or more choices.</p>
        <p>One issue with this level of nesting is that the code can become very complex if we're following the indentation conventions. For instance, if there were 10 different choices in an if/else chain (not unheard of), the last else statement would be indented at least 20 spaces!
        </p>

        <p>
            To avoid this complexity in the code, there are coding conventions that dictate when you should use curly braces and how much you should indent to avoid very wide lines in your code, summarized in the figure above. Rather than opening a brace for each else statement, instead, when an else statement is followed by another if, no brace is opened and the if immediately follows the else on the same line. Then a brace is opened for the if statement and also the final trailing else statement.
        </p>
 <example>
     <title>Ice Cream Choices with if/else Chains</title>
    <p>An application is being developed that can order an appropriate snack for you automatically. If the temperature outside is high, it will order an ice cream, and if the temperature is low, it will order a hot chocolate. Assume that there are two methods available that can order either of these foods. The code might look like this:
    </p>
<programlisting>
if ( temperature > 65 ) {
  orderIceCream();
} else {
  orderHotChocolate();
}
</programlisting>
    <p>
    Now consider that the application might also order popcorn if the temperature is more moderate. We would have to use a nested if statement to accomplish this:
    </p>
<programlisting>
if ( temperature > 80 ) {
  orderIceCream();
} else {
  if (temperature > 50 ) {
    orderPopcorn();
  } else {
    orderHotChocolate();
  }
}
</programlisting>
    <p>
    If we wanted to add, for example, 5 more snack options, this would become quite a mess, with many layers of nested if statements inside of else statements! Your code would be so far indented to the right, that it may begin to run over the length of the screen.
    </p><p>
    This is avoided by not opening a new curly brace for each if statement that immediately follows an else, and instead putting both on the same line. The body of the else then becomes the if statement that follows the else, and the following if statement is not indented further than the else that it follows. For example, we could re-write the code above this way:
    </p>
<programlisting>
if ( temperature > 80 ) {
  orderIceCream();
} else if (temperature > 50 ) {
  orderPopcorn();
} else {
  orderHotChocolate();
}
</programlisting>
 </example>
    </section>
    
    
    <subsection xml:id="section.else-statements">
        <info>
            <title>Else Statements</title>
        </info>
        <p>Conditional expressions provided a value whether our boolean expression evaluated to <c>true</c> <em>or</em> <c>false</c>. We can similarly provide an alternative block of statements we want executed if the boolean expression used in our if statement evaluates to false by using an <c>else</c> statement.
        </p>

        <figure>
            <title>if-else-statement</title>
            <caption>Anatomy of an if / else Statement</caption>
            <image source="figures/if-else-statement.png"/>
        </figure>

        <p>
            Else statements look exactly like if statements but must immediately follow the end of the if statement.
        </p>

        <example>
            <title>Implementing Absolute Value with if/else</title>
            <p>Recall the <c>abs</c> method from the <c>Math</c> class that determined the absolute value of a number. In this example, we'll write our own absolute valued method that does the exact same thing using an <c>if</c> and an <c>else</c> statement. We'll name this method <c>myAbs</c> to make it distinct:
            </p>
            <programlisting>
<xi:include href="../../../examples/code/myAbs.jsh" parse="text"/>
        </programlisting>
            <p>If <c>x</c> is greater than <c>0</c>, the first if statement will execute, meaning that the value stored in <c>x</c> will be returned. If <c>x</c> is not greater than zero, the return statement inside the <c>else</c> block will execute instead, meaning that the negation of the value stored in <c>x</c> will be returned. Note that <c>-0</c> is returned when <c>x</c> is stores the value <c>0</c>, but since these two values are equivalent, it doesn't make a difference. Also note that the return statement is still always the last statement executed, no matter what the value of <c>x</c> is. </p>
        </example>
    </subsection>
    
    
    
    
<section  xml:id="section.philosophy">
    <info>
        <title>Philosophy of this Book</title>
    </info>
    
    <subsection><title>Goals</title>
        <p>
            First and foremost, this book is intended to introduce students to programming and computer science. Beyond simply learning how to write programs in a particular programming language, this book is intended to assist in teaching students what programs are, what kind of problems can by solved by programs, how programs are used to solve problems, what the primary tools are for developing programs, and how students can progress in learning programming and computer science beyond the course in which they are using this book. For students who have had some experienceprogramming, perhaps in a self-taught environment, a course using this book should complement their experience by providing a solid background in programming fundamentals important to understanding more advanced concepts in computer science. To this end, this book doesn't avoid the technical terms and abstract concepts that a trade book may gloss over in an attempt to get students up and programming more quickly. 
        </p>
        <p>
            Secondly, this book is intended to introduce the Java programming language to someone new to programming. Prior programming experience is not assumed and the book is written for an audience that is programming for the first time. For this reason, this book is not intended to instill a mastery of Java and prioritizes instead the fundamental elements of programming that are applicable to students using any language, Java included, in the future. For students who want a more detailed explanation of a topic or wish to dive deeper in to the features of Java, references are made throughout the book to Oracle's official java language reference which is also freely available for use in a classroom setting: https://docs.oracle.com/javase/specs/jls/se10/html/index.html
        </p>
        <p>All that said, the material in this book could also be well suited to other purposes, such as a language-specific course on Java for students already past introductory computer science courses. In such cases, it is recommended that a customized version of the textbook be created (see the "Modular by Design" section below).</p>
    </subsection>
    
    <subsection><title>Why Java?</title>
        <p>Before heading any further, it's important to address a question you (the reader) have likely already answered, only because it bears some further consideration. The choice of language in CS1 is often not a choice for individual instructors. It might be dictated by department standards since future courses may use the same language. It might be partially dictated by the need for transfer students or students with AP credit to be able to move more quickly through a program. It might  even be partially dictated by the local industry that expect a certain set of proprietary skills in college graduates. Regardless of the reason you've chosen Java for your course, or in the case that you actually are currently openly considering adopting Java, I hope to convince you that it might be a better choice than you currently think, even if you already think it is a good one.</p>
        <p>Perhaps this section should be titled: "Why not Python?" Frankly, this is a good question. Before I get to Python, I should mention that my first programming language in academia was actually Scheme. Before I took H211 at Indiana University I had significant experience working with BASIC, C, and C++ -- none of which are languages I would ever teach to a beginner, in retrospect. I loved the way Scheme set all of the students on a level playing field, regardless of prior experience, but I loved even more how the simple syntax of Scheme allowed us to focus on fundamental programming concepts rather than the minutiae of a complex language like C++. Using the Scheme REPL also allowed me to learn quickly through ad-hoc experimentation in class. This took place in the 90's and it was still a more pedagogically effective approach for a CS1 course than anything I've seen since!</p>
        <p>Python has become a very popular CS1 language for many of the reasons Scheme remains the language of choice at IU. Python is also a natural scripting language, ships with a standard REPL, and through its syntax is more complex than Scheme, it's not as burdensome (some say "wordy") as Java has been known to be. It's also, like Scheme, a dynamically typed language. Not having to worry about assigning types to variables also makes it easier for programmers to get something up and running quickly in both Scheme and Python, which has obvious appeal to a CS1 instructor.</p>
        <p>Until recently, Java has had a very high barrier of entry for those developing simple programs. As a statically typed language, it was considered best suited to large, complex projects. Rather infamously, the most simple Java program you can write (hello world) is 5 lines long and contains enough programming concepts to span most of a CS1 course. Experimentation was difficult in Java because every change required recompilation, and a re-run through the program up until the point the change was made. </p>
        <p>Note that, in the previous paragraph, I was using past tense. Java SE 9 brought an official REPL to Java (jshell), which for me, changed everything. Other REPL's had been available before, none truly made Java a scripting language -- at best they were just a way to play with expressions. JShell is not only a robust REPL for experimenting with Java in a CS1 class, it's also a standard REPL, meaning that it can be taught in CS1 with the expectation that it will still be a useful proprietary skill for the students later in their career. Coupled with the increased use of type inference in Java SE 8 (lambdas) and Java SE 10 (local variables), Java is well suited to not only help students get their programs up and running quickly, but also benefit from static type checking, making it easier for them to both debug their programs and understand the importance of type systems in a modern programming language. </p>
    </subsection>
    
    <subsection><title>Experiential Learning</title>
        <p>As a colleague of mine likes to say, "Programming is not a spectator sport." As important as it is for a student to understand the difference between a conditional expression and a conditional statement, a student must also be able to understand programming in a more innate way and develop the faculties to solve programming problems involving all of these abstract concepts. Since this book assumes no prior experience programming, it is intended to be used in a highly active learning environment that involves programming experiences. For this reason, instructional sections are intentionally succinct and rely more on examples to help students understand the concepts being taught. It is also expected that instructors will take advantage of most or all exercises available through this book in a course utilizing it. This book is not intended to teach these concepts independent of a hands-on environment for instruction.</p>
        
        <p>The advent of JShell makes it much easier to employ a more experiential approach to teaching programming, but textbooks need to adapt. For many, the main concern is when to introduce object oriented concepts when teaching Java. Because of JShell, it is now possible to write Java programs without having to write a class definition, which allows us to focus immediately on more fundamental imperative programming concepts first such as expressions and statements. This book does not avoid the topic of objects as a data type entirely, but does delay teaching the <em>definition</em> of new object types to focus on the core concepts of algorithms and imperative programming.</p>
    
    </subsection>
    
    <subsection><title>Modular by Design</title>
        <p>This book is truly a free and open-source textbook in the sense that, not only is it free to use (according to the creative commons license available at the end of the book), but also instructors are free to download and modify the XML documents it was developed from (again, subject to the constraints of the creative commons license). Every institution has different needs and instructors may have a different perspective on a topic or example that they would like to inject. This is encouraged. This textbook can be entirely customized to an individual course all they way to the level of the exercises, which can be interspersed in-line throughout the custom textbook. </p>
        <p>Sections of this book are intentionally cohesive and minimally coupled (to borrow some programming terminology). Of course, some sections will depend on other sections (class definitions don't make much sense unless you've already seen method definitions), but these dependencies are listed in a remark in the source XML for each section. As long as a dependent section isn't listed before the section it depends on, there shouldn't be a problem for students using a modified version of this book. Examples also carry prerequisites that may extend beyond a chapter's prerequisites. Depending on the order the instructor uses, you may need to update or replace the examples used in some of the sections. </p>
        <p>Not all sections carry the same amount of content, and some instructors may wish to spend more or less time with some sections. Between 1-3 sections can be covered in a 50-minute class period. When ordering a custom version of this book, it's recommended that you not include every section on, for instance, expressions, all in a row, but rather spread them out and cover them when they are most relevant to other material or projects you're using in the course. The standard version of the book does not group all related concepts in to single chapters for this purpose. Instead, each chapter is intended to cover approximately a weeks' worth of material in the order it is expected to be presented in class. </p>
    </subsection>
</subsection>





<section xml:id="section.variables">
    <info>
        <title>Variables</title>
    </info>
    
    <p>Notice that when you type an expression in to the JShell REPL, more than just the resulting value is printed to the screen. For example, when you type the literal expression 5 in to the REPL, this is what you see:</p>
    
<console>
<prompt>jshell> </prompt><input>5</input>
$1 ==> 5
</console>
    
    <p>The <c>$1</c> that you see indicates the name of an automatically generated variable. 
        <termdef xml:id="term.variable"> A <term>variable</term> is a named portion of computer memory that holds a single value. </termdef> 
        In this case, the value <c>5</c> is stored in computer memory at a location accessible with the variable name <c>$1</c>. 
        </p>
    
    <p>Variables in programming are similar to the idea of a variable you've seen in algebra. In algebra, the variable  represents an unknown quantity. Likewise, when you write a program, you may not know what value a variable you're using will eventually hold. However, at the time when your program is running (known as <term>run time</term>), the variable's value will be known to the computer, just as the        value of a variable in algebra is known when you solve an equation. </p>
    
    <p>When you type an expression in to the REPL, another variable will be automatically generated to hold the value. For instance:</p>
<console>
<prompt>jshell> </prompt><input>5</input>
$1 ==> 5

<prompt>jshell> </prompt><input>9</input>
$2 ==> 9         
</console>

<p>
    Variables aren't just used for storing values but can also be used to retrieve values. A <term>variable expression</term> is simply the name of a variable and evaluates to the value held by the variable. For example:
<console>
<prompt>jshell> </prompt><input>5</input>
$1 ==> 5

<prompt>jshell> </prompt><input>9</input>
$2 ==> 9

<prompt>jshell> </prompt><input>$1</input>
$1 ==> 5

<prompt>jshell> </prompt><input>$2</input>
$2 ==> 9
    
</console>
    Note that when a variable expression is evaluated by itself, another new variable is not automatically generated by the REPL to hold the value (that would be redundant). 
</p>
    
<p>
Variable expressions can also be part of more complex expressions by combining them with operators. For instance:
<console>
<prompt>jshell> </prompt><input>5</input>
$1 ==> 5

<prompt>jshell> </prompt><input>9</input>
$2 ==> 9

<prompt>jshell> </prompt><input>$1 + $2</input>
$3 ==> 14
</console>
</p>
</section>






<section xml:id="section.scripts">
    <info>
        <title>Scripts</title>
    </info>

    <p>
    	Together, a collection of statements comprises an imperative computer <term>program</term>. Even one statement by itself can be a program (such as the hello world example). However, typing each of these statements in to the REPL is tedious. Any useful programming language has a means to easily store and run programs.
    </p>

    <subsection>
    	<title>JShell Scripts</title>
    	<p>JShell also introduces a facility for this purpose that wasn't previously available to Java programmers. All of the statements you type in to a JShell session can be saved to a file by typing the following command in to JShell:
<programlisting>
/save myscript.jsh
</programlisting>
    	where <filename>myscript.jsh</filename> can be any file name of your choosing. A series of statements saved to a file in any programming language referred to as a <term>script</term>. The <filename>.jsh</filename> extension distinguishes in the filename distinguishes this file as a JShell script that can be loaded and executed. In fact, you can load and execute a script you've previously saved in JShell by typing in the following command:
<programlisting>
/open myscript.jsh
</programlisting>
    	</p>

        <xi:include href="../../examples/average-script.xml" parse="xml"/>

        <p>You may need to download a text editor if you wish to edit these scripts that you create. You can also use a text editor to create a new script from scratch. Some text editors have nice features for programmers like syntax highlighting. If you're using Windows, my favorite editor is Notepad++: <uri>https://notepad-plus-plus.org/</uri>. For any system, jedit (which was developed in Java) is also a good option: <uri>http://www.jedit.org/</uri>.
        </p>

        <p>
          Note that JShell was not officially meant to make Java in to a scripting language, and as such it has some frustrating limitations for this purpose. In particular, reading input from the user may not work as expected when running JShell instructions as a script. There are some workarounds available for this shortcoming, however.
        </p>
    </subsection>


    <subsection>
    <title>Inline Comments</title>
    	<p>
    		Programs that you write will quickly become so complex that it may not be easy to look at your code and understand what it will do (or what it is intended to do). Programmers deal with this problem with a liberal use of comments -- portions of source code that are intended to be read by other programmers and not interpreted as an instruction in the program.
    	</p>
    	<p>
    		The most common type of comments you'll find in any programming language are called inline comments (also called end-of-line comments, since they appear at the end of lines). In Java, at any point in a line of code, you can type two slashes. Everything following those slashes is ignored. Thus, its only purpose is to be read by you or other programmers to help understand your program.
    	</p>
    	<p>
    		Inline comments can also be used as placeholders for future instructions while you're writing a program. In this way, they can be seen as a go-between when converting the steps of an algorithm in to an actual computer program.
    	</p>

    	<p>
    		More often inline comments are used to explain what a significant or particularly complex snippet of code is intended to do (in plain English). It is often helpful to write these comments <em>first</em> and then write the code the comments are describing, but they can also be added to code later after a programmer realizes their code might not be so easy to follow.
    	</p>
    	<p>
    		There is a bit of an art to writing comments well, just as there is an art to writing programs well. Too few comments and it may not be clear what a program is doing. This can also make errors in the program harder to detect. Too many comments can make a program laborious to read and also wastes the programmer's time since writing comments takes careful thought. There are many rules of thumb, but some important ones are:
    	    <ul>
    	        <li>
    	            <p>Use descriptive variable names that do a lot of the job a comment might be intended for. If the variable's role is very simple, you may not need a comment describing its purpose. </p>
    	        </li>
    	        <li>
    	            <p>Do not use comments that merely repeat what a statement is doing, but rather explain the purpose behind one or more statements if that purpose is not immediately obvious. </p>
    	        </li>
    	        <li>
    	            <p>Otherwise, if it's not immediately clear what a statement is doing, it may deserve a comment, but put some thought in to whether your comment should cover just that one line of code, or perhaps several that are working closely together.</p>
    	        </li>
    	    </ul>
    	</p>

        <xi:include href="../../examples/commenting-averaging.xml" parse="xml"/>
    </subsection>
</section>






<section xml:id="section.command-line-arguments">
    <info>
        <title>Command-Line Arguments</title>
    </info>
    <p>
Though you should understand what the type <c>String[]</c> means at this point (an array of string values), it may not be clear why a parameter with this type must be provided to the main method. The purpose of this parameter is to hold any <term>command-line arguments</term> that may be provided to your application when it is started at the command prompt. This would allow you to write an application similar to <em>javac</em> itself!
    </p>
    <p>
Consider the following example program:
    </p>
<programlisting>
<xi:include href="../../examples/code/CommandLineDemo.java" parse="text"/>
</programlisting>

    <p>
    This application prints out each of the command line arguments given to it when it is executed. These arguments are specified at the end of the <em>java</em> command that starts the JRE.
    </p>

    <p>
    For example, if you were to compile and run this program with the following command:
    </p>
<console>
    <input>
    java CommandLineDemo here are some arguments
  </input>
</console>
    <p>
    ...the following would be printed to the screen:
    </p>

<console>
<output>
here
are
some
arguments
</output><!-- TODO: check to see if this renders correctly /-->
</console>
</section>


<section xml:id="section.applications">
    <info>
        <title>Java Applications</title>
    </info>

    <p>
        Previous sections explained how Java classes can be used to hold collections of static methods. They are also used as the entry points in to stand-alone Java applications.
    </p>
    <subsection>
        <title>Main Methods</title>
        <p>
        To run a java application, you must provide the Java runtime environment (JRE) with the name of a class representing a Java application. The JRE will then search for one particular static method called <c>main</c> and execute it. This is called the <term>entry point</term> to the application.
      </p>
      <p>
        The JRE is very picky about how <c>main</c> should be defined. Firstly, the name must be exact -- <c>main</c> must not be capitalized or otherwise misspelled. Next, the method (like the class definition) must be declared to be public. It also must be a static method, so both of these keywords need to preceed the rest of the method definition (typically public comes first, but the order is more of a style issue). Next, the return type of the method must be void. Finally, the method must have one parameter. The parameter can be named anything you want, though by convention it is given the name <c>args</c>. What is important is that the type of this parameter is an array of strings:  <c>String[]</c>.

        Putting this all together, the following serves as an example of a complete Java application:
        </p>
        <programlisting>
<xi:include href="../../examples/code/Hello.java" parse="text"/>
            </programlisting>
        <p>
        This is the classic <em>hello world</em> program that is often given on the first day of a programming class. In many languages, <em>Hello World</em> is simply a one-line program, making this a convienent place to start in an introductory programming class. However, Java was designed with more complex software development in mind, and a more complex <em>Hello World</em> example is one of the unintended side effects of that choice. By starting with a tool like JShell, you were able to learn each of the concepts present in this code before using them in an application (with the exception of the <c>public</c> keyword, to some extent).

        Note that this program would have to be defined in a file called <c>Hello.java</c>.
        </p>
    </subsection>
    <subsection>
        <title>Compiling and Running Java Programs</title>

        <p>
          If you develop a java file such as <c>Hello.java</c>, you must first compile it before you run it. Recall that typing <em>jshell</em> at the command prompt started up the jshell REPL. Similarly, you can compile this Java program at the command prompt by typing:
       </p>
       <console><input>javac Hello.java</input></console>
       <p>
          If the command was successful, you should see a file in your directory called <c>Hello.class</c>. If it was unsuccessful, you will recieve an error message. Generally, you can compile any other Java file by including its file name in the place of <c>Hello.java</c>.
        </p>
        <p>
          Once your program is compiled successfully, you can run it by typing the command:
        </p>
        <console><input>java Hello</input></console>
        <p>
          This starts up the JRE and tells it to look for a main method in the class <c>Hello</c>. If you did not properly define your main method, you may receive an error message at this point. Otherwise, you will see the welcome message printed in the console.
        </p>

    </subsection>
</section>






<section xml:id="section.assignment-statements">
    <info>
        <title>Methods with No Return Type</title>
    </info>
    
    <p>
Not every method will need to return a value. This section will look at at one possible rationale for writing such a method.
    </p>
    <subsection>
        <title>The void Keyword</title>
        <p>
            Though not every method has a return value, method definitions require \textit{something} in the place of the return type in the method definition header. If no value is returned by the method, the \textbf{void} keyword is used to indicate such. If you use the void keyword in your method definition, you are not required to have a return statement in your method definition. Thus, the following is legal:
        </p>
        
<programlisting>
void methodWithNoReturnStatement() {
// this method literally does nothing
}
</programlisting>

    </subsection>
    <subsection>
        <title>Printing to Standard Output</title>
        <p>We've received messages back from the REPL each time we evaluate an expression, but perhaps we would like a message to be delivered somewhere during the execution of our program. Many ``text-based'' applications interact with their users solely through messages printed to a console (such as the REPL itself). Java has a special function for printing such messages to what is called \textit{standard output} or \textit{the console}. In the case of jshell, standard output is simply the jshell screen, so any messages you print while using jshell will show up there.
        </p>
        
        <p>The method we will use to print to standard output is unfortunately (and infamously) somewhat complicated looking. Technically, it is an instance method that we call from a PrintWriter object. The PrintWriter object in question is a static variable in the \textbf{System} class called \textbf{out}, and the instance method we'll call from this object is called textbf{println}. So all together, we'll be calling this method by calling \textbf{System.out.println}. If the last sentence is all you remember from this paragraph, that's all you'll need for the rest of the semester. 
            
        </p>
        
        <p>This method will take one argument -- whatever we want printed to standard output. So, if we want to print the number 5 to our jshell screen, we can use the following method call:
        </p>
        
        <programlisting>
System.out.println(5);
        </programlisting>
        
        <p>Note that this method doesn't return anything. It will take any type of expression we give it, however. So the following code:
        </p>
        
        <programlisting>
System.out.println("Joseph Kendall-Morwick");            
        </programlisting>
        
        <p>prints my name to standard output, and the following code:</p>
        
        <programlisting>System.out.println(1 + 1 == 2);</programlisting>
        
        <p>
            prints the value \textit{true} to standard output.  Note that if you don't want a newline printed, you can use System.out.print instead. This allows you to make multiple calls without continuing to the next line. For instance:
        </p>
        
        
<programlisting>
System.out.print("hi");
System.out.print(" ");
System.out.print("there");
</programlisting>
        <p>would print:</p>
        
<console><output>hi there</output></console>
    </subsection>
</section>



<section xml:id="section.varargs">
    <info>
        <title>Variable Number of Arguments</title>
    </info>

<p>All the method definitions we've examined thus far have required the programmer to be explicit about the number of parameters for the method and their types. Thus the programmer can't define a method that could take either 1, 2, or 3 arguments -- the number of arguments would always need to be the same.
</p>


    <p>
There is a way around this limitation. We could define a method that has an array-type parameter. The array argument we pass in to this method could be of any length, so we could package our arguments inside of it.
</p>

<example>
    <title>Sum an Array of Integers</title>
<p>If we wanted to write a method that would add several numbers together, we could package all those numbers in an array before we pass them to the method:
</p>
<programlisting>
  int sum(int[] numbers) {
    int total = 0;
    for(int number : numbers) {
      total += number;
    }
    return total;
  }
</programlisting>

<p>If we had three integer variables we wanted to add together, we could then pass them in within a literal array:
</p>

<programlisting>
  sum(new int[] {a, b, c})
</programlisting>

</example>
<p>
Since Java 5, variable number of arguments has been supported in Java, allowing us to perform the same task as the method above, but with a cleaner looking syntax. Using the varargs syntax, we'll declare that our method accepts an integer instead of an array. The difference will be that we'll include an ellipsis in between the type (<c>int</c>) and the variable name. The variable will still hold an array of integers in this case, not a single integer. This syntax can be used for any type (not just integers). You could write a varargs method that takes an arbitrary number of <c>String</c> parameters, for example. 
</p>

<example>
    <title>Sum a Variable Number of Integer Arguments</title>
<p>We could rewrite the example above using variable arguments as follows:
</p>
<programlisting>
  int sum(int ... numbers) {
    int total = 0;
    for(int number : numbers) {
      total += number;
    }
    return total;
  }
</programlisting>

<p>There is very little difference in the method definition, but now we don't need to create a literal array when we pass in a variable number of arguments. This version of sum can be called as follows:
</p>

<programlisting>
  sum(a, b, c)
</programlisting>
</example>
</section>



<section xml:id="section.overloading">
    <info>
        <title>Overloading Method Parameters</title>
    </info>

<p>What if the programmer wanted to develop a method that could take more than one type of argument? You may have noticed in the past that the <c>abs</c> method in the <c>Math</c> class works with either <c>int</c> values or <c>double</c> values. That is because there are two different implementations of this method, one for each of these parameter data types. This is called <term>overloading</term>.
</p>
    <p>
Methods in Java are not identified by their name alone. If you were to call <c>Math.abs(5)</c>, the Java compiler will search for a method named <c>abs</c> that has exactly one parameter of type <c>int</c> to bind this call to. There may be another method named <c>abs</c> that has a parameter of type <c>double</c>, or more than one parameter, or no parameters, etc..
    </p>

    <example>

        <p>Consider the following method definitions:</p>

<programlisting>
int abs(int a) {
  System.out.println("abs was called with an int");
  return a > 0 ? a : -a;
}

double abs(double a) {
  System.out.println("abs was called with an double");
  return a > 0 ? a : -a;
}
</programlisting>

<p>The implementations of these methods look nearly identical, but if you enter them in to jshell and then evaluate the following statements:
</p>
<programlisting>
abs(-5);
abs(-5.0);
</programlisting>

<p>You will see that one returns an integer value and the other returns a double value, as well as each printing out a different message.
</p>
    </example>
</section>


<section xml:id="section.method-definitions">
    <info>
        <title>Method Definitions</title>
    </info>
    
    <p>In prior sections we used method calls to do some of the computing for us. For example, a call to the <c>max</c> method in the <c>Math</c> class was a simple way to achieve what would have otherwise required more detailed code. In this section you will learn how to define your own custom methods. 
    </p>
    
    <p>
        Method definitions are a bit more involved than our previous topics. Methods take data (arguments) as input (through <term>parameters</term>) and return data as output (called the <term>return value</term>). The data types for both a method's input and output must be specified (similar to how you could specify the data type when you create a variable, though in this case it's required). Below is a diagram of the syntax of a method definition.
    </p>
  
    <figure>
        <title>method-definition</title>
        <caption>Anatomy of a Method Definition</caption>
        <image source="figures/method-definition.png"/>
    </figure>
  
        <p>
            A method definition consists of a header (or signature) defining the input and output data types, and a method body. Let's first take a look at the contents of the signature. First is a data type for the data returned by the method. For instance, the <c>abs</c> method in the <c>Math</c> class returns a double, so it's return type would be <c>double</c>. Next is the name of the method. 
        </p><p>
    So far, the definition looks a lot like a variable definition, but we're not quite finished. We also need to define parameters for the method. Parameters are variables that will hold the input values for the method (the input values are what we referred to as arguments in prior sections). Following the name of the method is a pair of parentheses with definitions of the parameters in between the parentheses. Each parameter definition consists of a data type followed by the name of the parameter (just like the variable definitions we saw previously but without the semicolon at the end). There may be zero or more parameter definitions, separated by commas. 
        </p><p>
    The method body consists of an open curly brace, 0 or more statements, and a closing curly brace. Unlike if statements, the method body must be contained within two curly braces (there is not option for a single-statement body with no curly braces). These statements can do anything you want with the restriction that your method must reach a special kind of statement called return statement when it is finished (with some exceptions -- but for now assume this is always true). The return statement must be the last statement executed in the method and it returns the value that a call to the method would evaluate to. 
    </p>
        
        <example><title>Square a Number</title>
        <p>Below is the definition of a method that will simply square the number passed in to it.</p>
<programlisting>
int square(int x) {
  return x * x;
}
</programlisting>
            <p>Note that it has only one parameter, <c>x</c>, and one statement in the method body, the return statement. Defining and then calling this method in jshell will look like this:</p>
            
<console>
<prompt>jshell> </prompt><input>int square(int x) {
   ...>   return x * x;
   ...> }</input>
|  created method square(int)

<prompt>jshell> </prompt><input>square(4)</input>
$2 ==> 16

<prompt>jshell> </prompt><input>square(10)</input>
$3 ==> 100

</console>
            
            <p>Notice that jshell doesn't include the name of the parameter <c>x</c>
            in the message reporting that you successfully defined the method. That's because the
            name of the parameter is ultimately not important. The parameter's name is meant to help
            make the code defining your method easier to read and understand, and also to describe
            the purpose of the parameter to the programmer writing code that calls it. What's most
            important from a functional perspective is that you've defined a method that can take an
                <c>int</c> type argument and that it will return another <c>int</c> type
            value to you. </p>
        </example>
        <example><title>Add Two Numbers</title>
            <p>Below is an example of a method definition with more than one parameter. It might not be particularly useful, but it demonstrates how to work with more than one argument in your methods:</p>
<programlisting>
int add(int x, int y) {
  return x + y;
}
</programlisting>     
            <p>Calling this method in jshell would look like this:</p>
<console>
<prompt>jshell> </prompt><input>add(4, 5)</input>
$2 ==> 9

<prompt>jshell> </prompt><input>add (10, -2)</input>
$3 ==> 8
</console>
        </example>
        
        <example><title>Ultimate Answer</title>
        <p>Some methods don't have any parameters at all. For example, below is the definition of a method that simply returns the value <c>42</c>:</p>
<programlisting>
int ultimateAnswer() { 
  return 42;
}
</programlisting>  
            <p>Calling this method in jshell would look like this:</p>
            
<console>
<prompt>jshell> </prompt><input>ultimateAnswer()</input>
$2 ==> 42    
</console>   
            <p>This method clearly doesn't do much and there are better alternatives to storing a single value, but there will be many opportunities for writing a meaningful method with no parameters as long as it performs some useful side effect, like printing to the screen.</p>
        </example>
    
</section>



<section xml:id="section.strings">
    <info>
        <title>Strings</title>
    </info>
    <p>A single character by itself doesn't convey much. The kind of data we more often want to
        work with is a sequence of multiple characters, like a name or address field, or even
        something longer and more complex like a news article or a computer program. Java has a
        data type that fits this role: the <c>String</c>. While a character literal only holds
        a single value, such as <c>'h'</c>, a string can hold 0 or more character
        values. Thus, strings can represent more complex data like names, sentences, or even this
        entire book! You can create a variable of type <c>String</c> as follows: </p>
    <programlisting>String name;</programlisting>
<p>
    Note that the type in that variable declaration is capitalized. That's because, unlike <c>char</c>'s and <c>int</c>'s, the string type is an object type (not a primitive type). Thus, when we use the string type in Java code (such as the example above), it must be capitalized. However, unlike <c>Point</c>s and other objects we've played with, strings are a special object type in Java in that they see very heavy usage and also have some special syntax associated with them (described in the following sections).
</p>
<section>
    <title>String Literals</title>

    <p>String literals have a special syntax somewhat similar to character literals. Character literals are a single character surrounded by single quotes, such <c>'a'</c>. String literals are similar, but as noted, there may be more than one character in the string, and we use double quotes to surround them. For example, the following code initializes the name variable from the previous example with my name as a value: </p>
    <programlisting>name = "Joesph Kendall-Morwick";</programlisting>

    <p>Note that string literals can contain all sorts of characters, including spaces and dashes. Strings also distinguish between upper and lower case characters. Character literals work just the same way, but character literals hold exactly one character.
    </p>

    <p>String literals may also hold zero characters. For instance:</p>

    <programlisting>name = "";</programlisting>

    <p>is also legal. Note that the empty string (above) is still a string value! It doesn't mean there isn't a string held by the variable <c>name</c>. If <c>name</c> held no value, we would say it holds the <c>null</c> value, just as any other object-type variable that doesn't hold a value. Recall that <c>null</c> is a keyword representing this value:
    </p>

    <programlisting>name = null;</programlisting>

    <p>Note that there are no quotes around <c>null</c>, since it is a keyword. </p>

</section>


    <subsection>
        <title>String Concatenation</title>

        <p>Two string values may be joined together with the concatenation operator.
            Unfortunately, you've technically already seen the concatenation operator because it
            uses the same symbol as the addition operator (+). However, they are considered distinct
            operators since they take distinct actions on their operands. You will end up with
            addition or concatenation depending on the data types of the operands. Allowing an
            operator to take on multiple meanings depending on the types of the operands is more
            generally referred to as <term>operator overloading</term>. </p>

<example><title>Basic Concatenation</title>
    <p>The following code:</p>
<programlisting>
String fullName = "Joseph" + " " + "Kendall-Morwick";
</programlisting>
    <p>
        will store a single string value representing my full name in the variable <c>fullName</c>.</p>
</example>

<p>In fact, concatenation is performed when even just one of the operands is a string value. The other value will be coerced (transformed) in to a string value.
</p>


<example><title>Concatenating non-Strings</title>
    <p>The following code:</p>
<programlisting>
String message = "my favorite number is " + 5;
</programlisting>
    <p>will store a single string value holding the message "my favorite number is 5" in the variable <c>message</c>.</p>
</example>
    </subsection>
<subsection>
    <title>String Instance Methods</title>

    <p>The string class has many useful instance methods. We'll take a look at five of the most important ones.
    </p>

    <subsubsection><title>length</title>
        <p>The <c>length</c> instance method has no parameters but returns the length of the string (as an integer).
        </p>

    <example>
        <title>Finding the Length of a String</title>

        <programlisting>"hello".length() </programlisting>

        <p>evaluates to the value 5 whereas</p>

        <programlisting>"".length()</programlisting>

        <p>evaluates to the value 0</p>
    </example>
    </subsubsection>

    <subsubsection><title>equals</title>

        <p>The <c>equals</c> instance method takes another String as input and returns a boolean value (<c>true</c> or <c>false</c>) indicating whether the two strings (the argument and the string from which the method is being called) have the exact same contents or not. Boolean values are described in more detail in another section. </p>
        <example>
            <title>Comparing two Strings</title>
            <programlisting>"hello".equals("hello") </programlisting>
            <p>evaluates to the value <c>true</c> whereas</p>
            <programlisting>"hello".charAt("Hello") </programlisting>
            <p>evaluates to the value <c>false</c></p>
        </example>
    </subsubsection>

    <subsubsection><title>charAt</title>

        <p>The <c>charAt</c> instance method takes the location (called the index or offset) of a character in the string and returns just that character (as a character-type value). The tricky part of working with string indexes is that the first index is zero (not one). </p>
        <example>
            <title>Pulling a character out of a String</title>
            <programlisting>"hello".charAt(0) </programlisting>
            <p>evaluates to the value <c>'h'</c> whereas</p>
            <programlisting>"hello".charAt(4) </programlisting>
            <p>evaluates to the value <c>'o'</c></p>
        </example>
    </subsubsection>

    <subsubsection><title>char</title>

        <p>The <c>indexOf</c> instance method takes a character you're searching for as input and returns the first index of where it's found in the string. If the character is not present in the string, <c>-1</c> is returned instead. </p>

    </subsubsection>

    <subsubsection><title>substring</title>

        <p>        The <c>substring</c> instance method takes two integer values (indexes) as input and returns a substring of the original string starting at the first index and ending just before the last index. Be mindful of the fact that the first index given indicates where the substring starts (and the character at this index is included in the resulting substring), but the second index is expected to be one greater than the index of the last character included (so the character at the second index is not included). The second index is also optional -- if it is omitted, all characters following the first index are included in the resulting substring. This can be a little confusing, so make sure that the examples below make sense and try some others out in JShell.
  </p>
        <example>
            <title>Pulling a substring out of a String</title>
            <programlisting>"hello".substring(1, 3) </programlisting>
            <p>evaluates to the value <c>"el"</c></p>
        </example>
        <example>
            <title>Pulling a prefix out of a String</title>
            <programlisting>"hello".substring(1) </programlisting>
            <p>evaluates to the value <c>"ello"</c></p>
        </example>
    </subsubsection>

    <p>The examples above show instance methods being called from String literals. Bear in mind that these methods can be called on any expression that results in an object value, not just literals! In fact, you will more often be calling instance methods from variable expressions. Instance method calls are also often composed with other instance method calls to form more complex expressions, just as we've done with static method calls and operators in previous examples. </p>
    <example>
        <title>Find the name that starts with a capital J</title>
<programlisting>var names = "Mary. Sam. Joey. Abigail.";
var namesStartingAtJ = names.substring(names.indexOf('J'));
var endOfName = namesStartingAtJ.indexOf('.');
var nameStartingWithJ = namesStartingAtJ.substring(0, endOfName);
</programlisting>
        <p>In a String listing several capitalized names ending in periods, this code locates and isolates the first name that begins with a J. After each of the four statements are executed, the variable <c>nameStartingWithJ</c> will contain the value <c>"Joey"</c>.</p>
    </example>

</subsection>


    <subsection><title>String Escapes</title>
        <p>There are also some special values that strings (and characters) can hold, such as new lines (a character representing that the cursor drops to the next line), tabs (a character represeting that the tab key was pressed), and so on. These are insterted in to string (and character) literals by including a backslash (called an escape) before a special code. These special characters are interpreted when we print out strings. For example, consider the following print statement:
        </p>
        <programlisting>print("A tab is \n\ta quite simple way \n\t\tto advance");</programlisting>

        <p>...prints the following haiku to the console:</p>

<console><output>
A tab is
a quite simple way
to advance
</output></console
        <p>It is important to note that because back slashes are interpreted as escapes, they can not be used as any other character would be in a string. However, you can include them by escaping them! For instance, the following code:
        </p>

        <programlisting>print("here's a backslash: \\");</programlisting>
        <p>prints the following to the standard output:</p>
        <console><output>here's a backslash: \</output></console>
    </subsection>
</section>





<section xml:id="section.references">
        <title>Object References</title>
        <p>
            An important and subtle distinction in dealing with object type variables is that the values they hold are not the objects themselves, but rather <term>references</term> to the objects. In this sense, the <c>null</c> value indicates that a variable is not referencing any object value.
        </p>
        <p>
            This doesn't have particularly important implications when dealing with <term>immutable</term> objects like strings (immutable meaning that the values within the object cannot be changed). However, when we use a <term>mutable</term> object like an array, we need to be careful.
        </p>
        <subsection>
            <title>Copying Object References</title>
            <p>
                If you have a variable of type <c>int</c> and copy its value to another variable, you can expect that the value is truly copied. For example:

<programlisting>
int x = 5;
int y = x;
x = 10;
</programlisting>

                Tracing through this example, the value 5 was first assigned to x, then copied from x to y. Thus, when the value 10 is assigned to x on the last line, the copy of the value 5 held by y remains. Evaluating y would still yield the value 5.

                However, consider the following code:

<programlisting>
int[] x = new int[] {5};
int[] y = x;
x[0] = 10;
</programlisting>

                What would y[0] be? In this case, it would also be 10. Tracing through this example, in the first line, an array is created holding just one value, 5, and a reference to this array object is stored in the variable x. Next, the reference to this object is copied from x and stored in y. That is, both x and y are holding references to the same object! The third line changes the value inside of this array, meaning that both x and y are now referencing an array that contains the value 10!

            </p>
        </subsection>
        <subsection>
            <title>Methods with Side Effects</title>
            <p>
                In prior sections we've developed methods that take some kind of input, perform some calculations on the input, and produce an output without affecting the values that were passed in. Consider the following code:

<programlisting>
int x = 5;
int y = 10;
System.out.println(Math.max(x, y));
System.out.println(x);
System.out.println(y);
</programlisting>

                This code will print the values 10, 5, and 10 on three separate lines. In particular, we can rest assured that Math.max has no impact on the values that x and y hold. This is because Math.max has no <term>side effects</term>; that is, it does not have any impact on any part of a program calling it (other than its own local variables).
              </p>
              <p>
                This is not true of every method. For example, calling <c>System.out.println()</c> modifies the global state of the program, since it writes to standard output.
              </p>
              <p>
                Consider the following method:

<programlisting>
void clearArray(int[] arr) {
    for(int i=0; i &lt; arr.length; i++) {
      arr[i] = 0;
    }
}
</programlisting>
                    Note that the method above has no return value. It modifies the state of an array value that is passed in. This is another example of a potentially useful side effect. Clearly not all side effects are bad, but inadvertent or unexpected side effects are the source of many confusing and troublesome bugs in more complex programs.
            </p>
        </subsection>
    </section>
    
    
    
<section xml:id="section.characters">
    <info>
        <title>The Character Primitive Data Type</title>
    </info>
    <p>A character is essentially another type of numeric primitive, but with a special purpose. In order to work with textual data on a computer (such as the letters you're reading right now, which were printed off by a computer), each letter (and also other symbols such as punctuation, numbers, etc) are each given a special code number.</p>
    <p>Characters are a primitive type in Java, and the name of the type is <c>char</c>. Thus, just like <c>int</c> and <c>double</c>, you can create a variable of type <c>char</c>:
    </p>

<programlisting>
char letterGrade;
</programlisting>

  <p>There is also a special format for character literals. You can surround a character with single-quotes and Java will interpret that as a literal character value. For instance:</p>

<programlisting>
letterGrade = 'A';
</programlisting>

<p>Since Java was designed to work on any available computing platform, naturally it should also support any language as well. Thus, the standard used for the characters in Java include codes not only for the letters used in English, but also all other natural languages (including those with many characters, such as Japanese)! This system is called Unicode:
    <uri>https://unicode.org/</uri></p>


<p>The actual codes used for each character in Java can be looked up on the UTF-8 chart here: <uri>https://www.unicode.org/charts/</uri>  Note that you can convert between the character codes and character literals by casting them back and forth to other integer types. For example, the following expression: <programlisting>(int)'a'</programlisting> will evaluate to the integer value <c>97</c>, which was designated for this character in unicode. The rest of the lower-case characters in the basic latin alphabet are assigned to each of the following integers, so similarly evaluating the expression: <programlisting>(int)'b'</programlisting> will evaluate to <c>98</c></p>


    <subsection>
        <title>Methods for Characters</title>
        <p>Just as with mathematical functions, there are also some <em>built in</em> methods for working with characters. You can make them available in the REPL by typing in the following statement:

<programlisting>
import static java.lang.Character.*;
</programlisting>

            A couple important ones are summarized below:

        <dl>
            <!-- these will need to be covered after booleans are
            <li>
                <p><c>boolean isDigit(char)</c> - Takes a character as input and returns a boolean indicating whether or not it is a digit (0-9). </p>
            </li>
            <li>
                <p><c>boolean isLetter(char)</c> - Takes a character as input and returns a boolean indicating whether or not it is a letter (a-z or A-Z). </p>
            </li>
            <li>
                <p><c>boolean isUpperCase(char)</c> - Takes a character as input and returns a boolean indicating whether or not it is a upper-case letter (A-Z). </p>
            </li>
            <li>
                <p><c>boolean isLowerCase(char)</c> - Takes a character as input and returns a boolean indicating whether or not it is a lower-case letter (a-z)</p>
            </li>
            -->
            <li>
                <p><c>char toUpperCase(char)</c> - Takes a character as input and returns that character in upper-case (or leaves it alone if it was already upper-case)</p>
            </li>
            <li>
                <p><c>char toLowerCase(char)</c> - Takes a character as input and returns that character in lower-case (or leaves it alone if it was already lower-case)</p>
            </li>
        </dl>
    </p>
        <!-- this will need to be covered after booleans are
        -        <p>Executing the following code:</p>
-
-    <programlisting>
-char c = 'A';
-if(Character.isUpperCase(c)) {
-  c = 'a';
-}
-    </programlisting>
-
-    <p>would result in textit{c} holding the value 'a' at the end.  The following code would also produce the same result:
-    </p>
-
-    <programlisting>
-char c = 'A';
-c = Character.toLowerCase(c);
-    </programlisting>
-->
    </subsection>
</section>



<section xml:id="section.arrays">
    <info>
        <title>Arrays</title>
    </info>

    <p>
Strings are a collection of characters, but we haven't yet seen a way to handle a collection of other types of values. Arrays allow Java programmers to create collections of values of an arbitrary type.
    </p>

    <subsection>
        <title>The Array Type</title>
        <p> Arrays themselves are a type of data, but are parameterized by the type of data they hold (that is to say, there are many 'array types' and each is distinguished by the type of data held by an array of that type). Values in an array can have any type, but they must all have the <em>same type</em> as each other.
        </p>
        <p> The syntax for an array type has two parts: the type of data held by the array, and a pair of square brackets indicating an array type. For example, the type <em>array of integers</em> would be written: <c>int[]</c>
        </p>
        <p> A variable named <c>arr</c> that could hold an array of integers is defined as follows:
            <programlisting>int[] arr;</programlisting>
        </p>
    </subsection>
    <subsection>
        <title>Creating Array Values</title>
        <p>Like strings, arrays are object types. Thus, variables with array types can be null:

          <programlisting>int[] arr = null;</programlisting>

            We also create array objects with the <c>new</c> keyword, although the syntax is a little different than it is for other constructor calls. Square brackets are used instead of parentheses and the size of the array is provided within the square brackets. The size is constant and cannot be changed over the lifetime of the array object you create. For example, the following code initializes <c>arr</c> to contain an array of 5 integers:

          <programlisting>int[] arr = new int[5];</programlisting>

            Each of the integers in the array <c>arr</c> are initialized to zero in the previous example. However, we can initialize them to hold arbitrary values by enumerating those values within curly braces instead of providing the length of the array. For example, the following code initializes <c>arr</c> to hold the values 1 through 10:


          <programlisting>int[] arr = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</programlisting>
        </p>
    </subsection>
    <subsection>
        <title>Operations on Arrays</title>
        <subsubsection>
            <title>Length of an Array</title>
            <p>
                The first operation to consider on arrays is how to determine the length of an array. This is similar to determining the length of a string, but instead of calling a method, the <c>length</c> field is accessed instead. For example, assuming the most recent definition of <c>arr</c>, the following expression will evaluate to <c>10</c>:

          <programlisting>
                arr.length
          </programlisting>

                It is a very common mistake to include parentheses at the end of <c>length</c> for an array or to leave off parentheses at the end of <c>length</c> for a string because of this unfortunate inconsistency.
            </p>
        </subsubsection>
        <subsubsection>
            <title>Accessing an Array</title>
            <p> The most important operation on arrays is retrieving a value from an array. This is very similar to the <c>charAt</c> instance method we used with strings, but instead of calling a method, square brackets following an array value indicate the index of the value to be retrieved. For example, assuming the most recent definition of <c>arr</c>, the following expression will evaluate to <c>1</c>:

<programlisting>arr[0]</programlisting>

                Note that the first index of an array is 0, just as with strings.</p>
        </subsubsection>
        <subsubsection>
            <title>Modifying an Array</title>
            <p>Though the size of an array can't change, the values it contains can. Think of an indexed array (an array value with an index following it in square brackets) as any other variable. In addition to evaluating it like a variable expression (above), we can also use it in an assignment statement. For example, the following statement will assign the value <c>100</c> to the first position in the array <c>arr</c>:
<programlisting>arr[0] = 100;</programlisting>
                Following this assignment statement, the following expression will evaluate to <c>100</c>:

          <programlisting>arr[0]</programlisting>
                      </p>
        </subsubsection>
        <subsubsection>
            <title>Iterating through an Array</title>
            <p>
                For loops are a very convenient way to process each element of an array. For example, the following code initializes <c>arr</c> to the values 1 through 10, but can be easily modified to have any upper limit:

<programlisting>
int size = 10;
int[] arr = new int[size];
for(int i=0; i&lt;arr.length; i++) {
    arr[i] = (i + 1);
}
</programlisting>
        </p>
        </subsubsection>
    </subsection>
</section>




<section xml:id="ex.classes">
    <title>Basic Class Definitions</title>

    <p>Every object type has a class definition associated with it, but classes in Java are also used for other special purposes, such as creating a collection of static methods (for example, the Math class) or for creating a Java application. Classes are the primary definition you'll find in a typical Java source-code file. These files end with the extension .java (rather than .txt or .jsh). 
    </p>
    <subsection>
        <title>Class and Static Method Definition Syntax</title>
        <p>A class definition begins with the keyword <c>class</c>, followed by the class name, and then a pair of curly braces. For example, here is a very simple class definition:
        </p>
<programlisting>
<xi:include href="../../examples/code/simple-class.jsh" parse="text"/>
</programlisting>
        <p>A Java file must contain one class designated as public using the <c>public</c> keyword before the class definition. It's also important to note that the filename must match the name of the public class, with <em>.java</em> at the end (similar to how an HTML file has <em>.html</em> at the end). For example, if we were to produce a Java file called <em>ExampleClass.java</em>, it could have the following as its contents:
        </p>

        <programlisting><xi:include href="../../examples/code/ExampleClass.java" parse="text"/></programlisting>
        <p>Inside of these curly braces is the class body in which its <term>members</term> are defined. Class members include method definitions, so we can include any of the method definitions we've been developing. If we make these methods static by including the <c>static</c> keyword before the method definition, we can use them like any other static method (such as <c>max</c> in the <c>Math</c> class). For instance, consider the following modification of the class definition above:
        </p>
      <programlisting><xi:include href="../../examples/code/ExampleClassWithStaticMethod.java" parse="text"/></programlisting>
        <p>Any other Java code we write, even in another file, could access this method as follows:
        </p>
<programlisting>
ExampleClassWithStaticMethod.sayHello();
</programlisting>
  <p>And in JShell, we could first use an import and then omit the class name when calling the method:
  </p>
<programlisting>
import static ExampleClassWithStaticMethod.sayHello;
sayHello();
</programlisting>
<p>If we want to use import statements in a Java file, they must all come before the class definitions (unlike JShell, where we could use import statements at any time). For example, if we want to use the <c>min</c> from the <c>Math</c> class in a method inside a class we define, we could import it at the top of the file:
</p>
<programlisting>
import static java.lang.Math.min;

public class ExampleClassWithImport {
  public int getValidGrade(int rawGrade) {
    return min(100, rawGrade);
  }
}
</programlisting>
    </subsection>
    <subsection>
        <title>Static Fields</title>
        <p>Methods aren't the only members we can add to a class. Variables can also be members, in which case they are called <term>fields</term>. For example, we can create a variable called <c>greeting</c> to hold the message we use in the <c>sayHello</c> method. This allows us to more easily maintain consistency with other methods that greet the user in other ways. <c>greeting</c> must also be declared static to be used as a general purpose method:
        </p>
        <programlisting><xi:include href="../../examples/code/ClassWithMultipleStaticMethods.java" parse="text"/></programlisting>
    </subsection>
    <subsection>
        <title>Scope of Fields</title>
        <p>Note that the variable <c>greeting</c> in the previous example is accessible in both of the static methods in the class. That is because the <term>scope</term> of the variable is the entire class definition body. Note that unlike other scope-limited variables, we can access the static scope of a class by giving the class name and following it with the dot operator:

<programlisting>
ClassWithMultipleStaticMethods.sayHello();
ClassWithMultipleStaticMethods.sayHelloEmphatically();
</programlisting>
        </p>

        <subsubsection>
            <title>Constants</title>
            <p>Because <c>greeting</c> is a member of the class, just like the <c>sayHello</c> method, it can be accessed from outside of the class as well. That means that the greeting could be modified from outside the class, such as in the following example:
            </p>

<programlisting>
ClassWithMultipleStaticMethods.greeting = "Hey Jerk";
</programlisting>

            <p>If a field is never meant to be altered, it should be made in to a <term>constant</term> by using the <c>final</c> keyword in its definition. Here is the updated definition of the running example that prevents any changes to the greeting field:
            </p>

          <programlisting><xi:include href="../../examples/code/ClassWithConstant.java" parse="text"/></programlisting>

        </subsubsection>
    </subsection>
</section>


<section xml:id="section.algorithms">
    <info>
        <title>Algorithms</title>
    </info>
    
    <p> 
        <termdef xml:id="term.algorithm">
            An <term>Algorithm</term> is a list of abstract instructions for solving a problem.
        </termdef>
        These instructions need not be computer codes -- an algorithm, as a concept, transcends any one particular programming language.</p>
    
    <p>Algorithms are often used to describe how to perform a complex mathematical operation by breaking it down in to a number of smaller steps. Though algorithms are not limited to manipulating numbers, some simple numerical examples work well to get the idea across.
    </p>
    
    <xi:include href="../../examples/average-algorithm.xml" parse="xml"/>
    
    <p>In this course you will write many computer programs in Java that implement algorithms. However, before we make that leap, we'll first learn about the basic building blocks of a Java program and weave them together to implement the steps in abstract algorithms.
    </p>
    
</section>



<section xml:id="section.style">
    <info>
        <title>Style</title>
    </info>

<p>Now that we're developing more complex code, it's important to take a step back and consider what aspects of the code are easier to understand or more aesthetically pleasing. This is important for a very practical reason: it's hard to develop, edit, or correct code that is difficult to read and understand. Thus there are common style conventions that should be followed while developing Java code.
</p>
    <subsection>
        <title>Block Indentation</title>

        <p>You've now seen two examples of a <em>block</em> in Java. <c>if</c> statements and method definitions both involved curly braces being opened around a series of statements. Every time you open a new block (that is, you open a curly brace), you should indent all statements within that block. Typically only 2 spaces are used rather than a full tab, since that block may contain another <em>nested</em> block, and so on, and using tabs can quickly lead to long lines and horizontal scrolling. Indenting helps you visually recognize what blocks each statement belong to. Thus, while reading a Java program, you can quickly skip over a block of code if you're not particularly interested in it.
        </p>
        <p>
            It's a fairly standard rule that you have no more than one statement on a line and always use a full line for a closing curly brace of a block, but there is some debate over whether you should open a curly brace for a block on the same line as an if statement or a method header, or whether you should open it on its own line. For instance:
        </p>
<programlisting>
int addStuff(int x, int y) {
  return x + y;
}
</programlisting>

        <p>and also</p>

<programlisting>
int addStuff(int x, int y)
{
  return x + y;
}
</programlisting>

        <p>are both considered good style by many. Mostly it's important that you're consistent with your choice on where to place the opening brace. In this book, we'll consistently use the style of the first example because that's the way the author was raised (and by extension, also now you).
        </p>
    </subsection>


    <subsection>
        <title>Block Comments</title>

    <p>At times a portion of your code will require a more significant explanation spanning multiple lines. Rather than beginning each of these lines with a double slash for an end-of-line comment, it may be preferable to designate a larger portion of your code for comments.</p>

<p>    Block comments are often used for these larger, more descriptive comments. To begin a block comment, type /* and all of the code, including newlines, will be considered a comment up to the closing */.</p>

<p>Another use of block comments is to temporarily <term>comment out</term> a portion of your code if you don't want it to run while you test your code but you also don't want to permenantly delete it. This can be helpful when debugging your more complicated programs. </p>
    </section>

    <section>
        <title>Javadoc Comments</title>
    <p>A special type of block comment is a <term>javadoc comment</term>. These comments come before each method definition and describe in detail what the method does, including the roles of its parameters and a description of the method's return value (if any). Javadoc comments begin with a <c>/**</c> instead of a <c>/*</c>
    </p>
        <p>
    Javadoc comments also have a special syntax for describing the parameters and return values. Within the Javadoc comment, a line beginning with <c>@return</c> will describe the return value and a line beginning with <c>@param</c> followed by the name of the parameter will describe one of the parameters. If you document your parameters in this way, you can also refer to your parameters in the rest of the comment with the following: <c>@code parameterName</c> where <c>parameterName</c> is the name of your parameter.
        </p>
        <p>
    If you use the Javadoc comment format, HTML documentation for your code can be automatically generated. In fact, the API documentation pages we've used previously were all automatically generated from javadoc comments in the API source code!
        </p>

        <example>
            The following method definition has an appropriate Javadoc comment preceding it:
        <programlisting>
<xi:include href="../../examples/code/javadoc-method-basic.jsh" parse="text"/>
        </programlisting>
        </example>

  </subsection>
</section>
